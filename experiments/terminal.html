<!DOCTYPE html>
<html>
    <head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
    </head>
    <body>
 	<canvas id="canvas" width="800" height="480"></canvas>
    </body>
    <script src="hidpi-canvas.min.js"></script>
    <script>
     let canvas = document.getElementById('canvas')
     let ctx = canvas.getContext('2d')
     let meta = {}
     let font = {}

     const wait = ms => new Promise((r, j)=>setTimeout(r, ms))
     const chunk = (r,j) => r.reduce((a,b,i,g) => !(i % j) ? a.concat([g.slice(i,i+j)]) : a, []);
     const index_to_coordinates = i => [i & 127, i >> 7]

     function greenify(img) {
	 let [w, h] = [Math.max(...meta.chars.map(c => c.xadvance)), meta.common.lineHeight]
	 
	 meta.chars.map((s, i) => {
	     ctx.clearRect(0, 0, w, h)
	     ctx.drawImage(img[s.page], s.x, s.y, s.width, s.height, s.xoffset, s.yoffset, s.width, s.height)
	     let imageData = ctx.getImageData(0, 0, w, h)
	     let data = imageData.data
	     for (var i = 0; i < data.length; i += 4) {
		 data[i]     = 0
		 data[i + 1] = data[i + 3]
		 data[i + 2] = 0
		 data[i + 3] = 255
	     }
	     
	     font[s.id] = {
		 glyph: imageData,
		 meta: s,
	     }
	 })

	 black()
     }

     function fetchfont() {
	 let loaded = () => {
	     console.log('done')
	 }
	 let fetch_image = u => {
	     return new Promise((resolve, reject) => {
		 let im = new Image()
		 im.onload = () => resolve(im)
		 im.onerror = reject
		 im.crossOrigin = "Anonymous"
		 im.src = u
		 return im
	     })
	 }

	 let base = 'https://guidoism.github.io/jonesforth/experiments/'
	 let url = base+'apl.fnt'
	 fetch(url)
	     .then(r => r.json())
	     .then(r => {
		 meta = r
		 Promise.all(r.pages.map(i => fetch_image(base+i))).then(img => greenify(img)).then(() => terminal())
	     })
     }

     function black() {
	 ctx.fillStyle = "black"
	 ctx.fillRect(0, 0, canvas.width, canvas.height)
     }

     function hex(buffer) {
	 let array = new Uint8Array(buffer)
	 let strings = Array.from(array).map(c => c.toString(16).padStart(2, '0'))
	 let chunked = chunk(strings, 4).map(c => c.join(''))
	 return chunked.join(' ')
     }
     
     let ram = new ArrayBuffer(64 * 1024)
     // We choose to have a screen 128 characters wide to make the cursor math easy. A 128x25
     // screen would be 3200 22 bit code point which would need 12,800 bytes of RAM if using
     // 32 bit numbers in the array.
     let screen_view = new Uint32Array(ram, 0, 3200)
     let screen_view_mut = new DataView(ram, 0, 3200*4)
     function update_screen() {
	 let [w, h] = [font[32].meta.xadvance, meta.common.lineHeight]
	 screen_view.map((c, i) => {
	     if (c > 0) {
		 ctx.putImageData(font[c].glyph, (i & 0b1111111)*w, (i >>> 7)*h)
	     }
	 })
     }

     let cursor = {x: 0, y: 0}
     function write(s) {
	 let offset = ((cursor.y << 7) + cursor.x) << 2
	 console.log(`Setting offset ${offset} with codepoint ${s.codePointAt(0)}`)
	 screen_view_mut.setUint32(offset, s.codePointAt(0), true)
	 console.log(hex(ram.slice(0, offset+4)))
	 update_screen()
	 cursor.x = (cursor.x + 1) % 80
	 if (cursor.x == 0) cursor.y += 1
     }

     function backspace() {
	 // TODO: Create wrapping adder with modulus
	 cursor.x -= 1
	 // todo set ram to zero
	 update_screen()
     }
     
     function terminal() {
	 document.addEventListener('keypress', e => write(e.key))
	 document.addEventListener('keyup', e => {if (e.keyCode == 8) backspace()})
     }
     
     fetchfont()
    </script>
</html>
