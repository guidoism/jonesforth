<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-04-06 Wed 23:31 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Guido Bartolucci" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgbc9808d">1. Introduction</a></li>
<li><a href="#orge79cc88">2. Acknowledgements</a></li>
<li><a href="#orgd3392ec">3. Public Domain</a></li>
<li><a href="#org4f50c78">4. Assembling</a></li>
<li><a href="#org40c9a1d">5. Assembler</a></li>
<li><a href="#org820fb08">6. The Dictionary</a></li>
<li><a href="#org0e868c6">7. Direct Threaded Code</a></li>
<li><a href="#orga2283bf">8. Indirect Threaded Code</a></li>
<li><a href="#orgc0ebaa2">9. The Interpreter and Return Stack</a></li>
<li><a href="#org943a4cf">10. Starting Up</a></li>
<li><a href="#orgb1aa2ba">11. Built-In Words</a></li>
<li><a href="#org60b6de2">12. Returning From Forth Words</a></li>
<li><a href="#org1125940">13. Literals</a></li>
<li><a href="#org8292166">14. Memory</a></li>
<li><a href="#orgfbdf3a0">15. Built-In Variables</a></li>
<li><a href="#org713b196">16. Built-In Constants</a></li>
<li><a href="#orged975fe">17. Return Stack</a></li>
<li><a href="#org63509cd">18. Parameter (Data) Stack</a></li>
<li><a href="#org6d31b5a">19. Input and Output</a></li>
<li><a href="#org0d31f54">20. Dictionary Look Ups</a></li>
<li><a href="#org81c32ab">21. Compiling</a></li>
</ul>
</div>
</div>
<p>
A sometimes minimal FORTH compiler and tutorial for Linux / i386 systems.
By Richard W.M. Jones &lt;rich@annexia.org&gt; <a href="http://annexia.org/forth">http://annexia.org/forth</a>
This is PUBLIC DOMAIN (see public domain release statement below).
</p>

<p>
Taken from jonesforth.S,v 1.47 2009-09-11 08:33:13 rich Exp
</p>

<div class="org-src-container">
<pre class="src src-shell">gcc -m32 -nostdlib -static -Wl,-Ttext,0 -Wl,--build-id=none -o jonesforth jonesforth.S
</pre>
</div>

<div class="org-src-container">
<pre class="src src-asm">.set JONES_VERSION,47
</pre>
</div>

<div id="outline-container-orgbc9808d" class="outline-2">
<h2 id="orgbc9808d"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
FORTH is one of those alien languages which most working programmers regard in the same
way as Haskell, LISP, and so on.  Something so strange that they'd rather any thoughts
of it just go away so they can get on with writing this paying code.  But that's wrong
and if you care at all about programming then you should at least understand all these
languages, even if you will never use them.
</p>

<p>
LISP is the ultimate high-level language, and features from LISP are being added every
decade to the more common languages.  But FORTH is in some ways the ultimate in low level
programming.  Out of the box it lacks features like dynamic memory management and even
strings.  In fact, at its primitive level it lacks even basic concepts like IF-statements
and loops.
</p>

<p>
Why then would you want to learn FORTH?  There are several very good reasons.  First
and foremost, FORTH is minimal.  You really can write a complete FORTH in, say, 2000
lines of code.  I don't just mean a FORTH program, I mean a complete FORTH operating
system, environment and language.  You could boot such a FORTH on a bare PC and it would
come up with a prompt where you could start doing useful work.  The FORTH you have here
isn't minimal and uses a Linux process as its 'base PC' (both for the purposes of making
it a good tutorial). It's possible to completely understand the system.  Who can say they
completely understand how Linux works, or gcc?
</p>

<p>
Secondly FORTH has a peculiar bootstrapping property.  By that I mean that after writing
a little bit of assembly to talk to the hardware and implement a few primitives, all the
rest of the language and compiler is written in FORTH itself.  Remember I said before
that FORTH lacked IF-statements and loops?  Well of course it doesn't really because
such a lanuage would be useless, but my point was rather that IF-statements and loops are
written in FORTH itself.
</p>

<p>
Now of course this is common in other languages as well, and in those languages we call
them 'libraries'.  For example in C, 'printf' is a library function written in C.  But
in FORTH this goes way beyond mere libraries.  Can you imagine writing C's 'if' in C?
And that brings me to my third reason: If you can write 'if' in FORTH, then why restrict
yourself to the usual if/while/for/switch constructs?  You want a construct that iterates
over every other element in a list of numbers?  You can add it to the language.  What
about an operator which pulls in variables directly from a configuration file and makes
them available as FORTH variables?  Or how about adding Makefile-like dependencies to
the language?  No problem in FORTH.  How about modifying the FORTH compiler to allow
complex inlining strategies &#x2013; simple.  This concept isn't common in programming languages,
but it has a name (in fact two names): "macros" (by which I mean LISP-style macros, not
the lame C preprocessor) and "domain specific languages" (DSLs).
</p>

<p>
This tutorial isn't about learning FORTH as the language.  I'll point you to some references
you should read if you're not familiar with using FORTH.  This tutorial is about how to
write FORTH.  In fact, until you understand how FORTH is written, you'll have only a very
superficial understanding of how to use it.
</p>

<p>
So if you're not familiar with FORTH or want to refresh your memory here are some online
references to read:
</p>

<p>
<a href="http://en.wikipedia.org/wiki/Forth_%28programming_language%29">http://en.wikipedia.org/wiki/Forth_%28programming_language%29</a>
</p>

<p>
<a href="http://galileo.phys.virginia.edu/classes/551.jvn.fall01/primer.htm">http://galileo.phys.virginia.edu/classes/551.jvn.fall01/primer.htm</a>
</p>

<p>
<a href="http://wiki.laptop.org/go/Forth_Lessons">http://wiki.laptop.org/go/Forth_Lessons</a>
</p>

<p>
<a href="http://www.albany.net/~hello/simple.htm">http://www.albany.net/~hello/simple.htm</a>
</p>

<p>
Here is another "Why FORTH?" essay: <a href="http://www.jwdt.com/~paysan/why-forth.html">http://www.jwdt.com/~paysan/why-forth.html</a>
</p>

<p>
Discussion and criticism of this FORTH here: <a href="http://lambda-the-ultimate.org/node/2452">http://lambda-the-ultimate.org/node/2452</a>
</p>
</div>
</div>

<div id="outline-container-orge79cc88" class="outline-2">
<h2 id="orge79cc88"><span class="section-number-2">2</span> Acknowledgements</h2>
<div class="outline-text-2" id="text-2">
<p>
This code draws heavily on the design of LINA FORTH (<a href="http://home.hccnet.nl/a.w.m.van.der.horst/lina.html">http://home.hccnet.nl/a.w.m.van.der.horst/lina.html</a>)
by Albert van der Horst.  Any similarities in the code are probably not accidental.
</p>

<p>
Some parts of this FORTH are also based on this IOCCC entry from 1992:
<a href="http://ftp.funet.fi/pub/doc/IOCCC/1992/buzzard.2.design">http://ftp.funet.fi/pub/doc/IOCCC/1992/buzzard.2.design</a>.
I was very proud when Sean Barrett, the original author of the IOCCC entry, commented in the LtU thread
<a href="http://lambda-the-ultimate.org/node/2452#comment-36818">http://lambda-the-ultimate.org/node/2452#comment-36818</a> about this FORTH.
</p>

<p>
And finally I'd like to acknowledge the (possibly forgotten?) authors of ARTIC FORTH because their
original program which I still have on original cassette tape kept nagging away at me all these years.
<a href="http://en.wikipedia.org/wiki/Artic_Software">http://en.wikipedia.org/wiki/Artic_Software</a>
</p>
</div>
</div>

<div id="outline-container-orgd3392ec" class="outline-2">
<h2 id="orgd3392ec"><span class="section-number-2">3</span> Public Domain</h2>
<div class="outline-text-2" id="text-3">
<p>
I, the copyright holder of this work, hereby release it into the public domain. This applies worldwide.
</p>

<p>
In case this is not legally possible, I grant any entity the right to use this work for any purpose,
without any conditions, unless such conditions are required by law.
</p>
</div>
</div>

<div id="outline-container-org4f50c78" class="outline-2">
<h2 id="org4f50c78"><span class="section-number-2">4</span> Assembling</h2>
<div class="outline-text-2" id="text-4">
<p>
If you want to actually run this FORTH, rather than just read it, you will need Linux on an
i386.  Linux because instead of programming directly to the hardware on a bare PC which I
could have done, I went for a simpler tutorial by assuming that the 'hardware' is a Linux
process with a few basic system calls (read, write and exit and that's about all).  i386
is needed because I had to write the assembly for a processor, and i386 is by far the most
common.  (Of course when I say 'i386', any 32- or 64-bit x86 processor will do.  I'm compiling
this on a 64 bit AMD Opteron).
</p>

<p>
Again, to assemble this you will need gcc and gas (the GNU assembler).  The commands to
assemble and run the code (save this file as 'jonesforth.S') are:
</p>

<div class="org-src-container">
<pre class="src src-shell">gcc -m32 -nostdlib -static -Wl,-Ttext,0 -Wl,--build-id=none -o jonesforth jonesforth.S
cat jonesforth.f - | ./jonesforth
</pre>
</div>

<p>
If you want to run your own FORTH programs you can do:
</p>

<pre class="example">
cat jonesforth.f myprog.f | ./jonesforth
</pre>

<p>
If you want to load your own FORTH code and then continue reading user commands, you can do:
</p>

<pre class="example">
cat jonesforth.f myfunctions.f - | ./jonesforth
</pre>
</div>
</div>

<div id="outline-container-org40c9a1d" class="outline-2">
<h2 id="org40c9a1d"><span class="section-number-2">5</span> Assembler</h2>
<div class="outline-text-2" id="text-5">
<p>
(You can just skip to the next section &#x2013; you don't need to be able to read assembler to
follow this tutorial).
</p>

<p>
However if you do want to read the assembly code here are a few notes about gas (the GNU assembler):
</p>

<ol class="org-ol">
<li>Register names are prefixed with '<code>%</code>', so %eax is the 32 bit i386 accumulator.  The registers
available on i386 are: <code>%eax</code>, <code>%ebx</code>, <code>%ecx</code>, <code>%edx</code>, <code>%esi</code>, <code>%edi</code>, <code>%ebp</code>, and <code>%esp</code>, and most of them
have special purposes.</li>
<li>Add, mov, etc. take arguments in the form SRC,DEST.  So <code>mov %eax,%ecx</code> moves <code>%eax</code> -&gt; <code>%ecx</code></li>
<li>Constants are prefixed with '<code>$</code>', and you mustn't forget it!  If you forget it then it
causes a read from memory instead, so:

<ul class="org-ul">
<li><code>mov $2,%eax</code>         moves number 2 into <code>%eax</code></li>
<li><code>mov 2,%eax</code>          reads the 32 bit word from address 2 into %eax (ie. most likely a mistake)</li>
</ul></li>

<li>gas has a funky syntax for local labels, where '<code>1f</code>' (etc.) means label '<code>1:</code>' "forwards"
and '<code>1b</code>' (etc.) means label '<code>1:</code>' "backwards".  Notice that these labels might be mistaken
for hex numbers (eg. you might confuse <code>1b</code> with <code>$0x1b</code>).
<ol class="org-ol">
<li>'<code>ja</code>' is "jump if above", '<code>jb</code>' for "jump if below", '<code>je</code>' "jump if equal" etc.</li>
</ol></li>
<li>gas has a reasonably nice .macro syntax, and I use them a lot to make the code shorter and
less repetitive.</li>
</ol>

<p>
For more help reading the assembler, do "info gas" at the Linux prompt.
</p>

<p>
Now the tutorial starts in earnest.
</p>
</div>
</div>

<div id="outline-container-org820fb08" class="outline-2">
<h2 id="org820fb08"><span class="section-number-2">6</span> The Dictionary</h2>
<div class="outline-text-2" id="text-6">
<p>
In FORTH as you will know, functions are called "words", and just as in other languages they
have a name and a definition.  Here are two FORTH words:
</p>

<div class="org-src-container">
<pre class="src src-forth">: DOUBLE DUP + ;                \ name is "DOUBLE", definition is "DUP +"
: QUADRUPLE DOUBLE DOUBLE ;     \ name is "QUADRUPLE", definition is "DOUBLE DOUBLE"
</pre>
</div>

<p>
Words, both built-in ones and ones which the programmer defines later, are stored in a dictionary
which is just a linked list of dictionary entries.
</p>

<pre class="example" id="orgfb97c27">
&lt;--- DICTIONARY ENTRY (HEADER) -----------------------&gt;
+------------------------+--------+---------- - - - - +----------- - - - -
| LINK POINTER           | LENGTH/| NAME              | DEFINITION
|                        | FLAGS  |                   |
+--- (4 bytes) ----------+- byte -+- n bytes  - - - - +----------- - - - -
</pre>

<p>
I'll come to the definition of the word later.  For now just look at the header.  The first
4 bytes are the link pointer.  This points back to the previous word in the dictionary, or, for
the first word in the dictionary it is just a NULL pointer.  Then comes a length/flags byte.
The length of the word can be up to 31 characters (5 bits used) and the top three bits are used
for various flags which I'll come to later.  This is followed by the name itself, and in this
implementation the name is rounded up to a multiple of 4 bytes by padding it with zero bytes.
That's just to ensure that the definition starts on a 32 bit boundary.
</p>

<p>
A FORTH variable called LATEST contains a pointer to the most recently defined word, in
other words, the head of this linked list.
</p>

<p>
DOUBLE and QUADRUPLE might look like this:
</p>

<pre class="example" id="orgda76ce5">
  pointer to previous word
   ^
   |
+--|------+---+---+---+---+---+---+---+---+------------- - - - -
| LINK    | 6 | D | O | U | B | L | E | 0 | (definition ...)
+---------+---+---+---+---+---+---+---+---+------------- - - - -
   ^       len                         padding
   |
+--|------+---+---+---+---+---+---+---+---+---+---+---+---+------------- - - - -
| LINK    | 9 | Q | U | A | D | R | U | P | L | E | 0 | 0 | (definition ...)
+---------+---+---+---+---+---+---+---+---+---+---+---+---+------------- - - - -
   ^       len                                     padding
   |
   |
  LATEST
</pre>

<p>
You should be able to see from this how you might implement functions to find a word in
the dictionary (just walk along the dictionary entries starting at LATEST and matching
the names until you either find a match or hit the NULL pointer at the end of the dictionary);
and add a word to the dictionary (create a new definition, set its LINK to LATEST, and set
LATEST to point to the new word).  We'll see precisely these functions implemented in
assembly code later on.
</p>

<p>
One interesting consequence of using a linked list is that you can redefine words, and
a newer definition of a word overrides an older one.  This is an important concept in
FORTH because it means that any word (even "built-in" or "standard" words) can be
overridden with a new definition, either to enhance it, to make it faster or even to
disable it.  However because of the way that FORTH words get compiled, which you'll
understand below, words defined using the old definition of a word continue to use
the old definition.  Only words defined after the new definition use the new definition.
</p>
</div>
</div>

<div id="outline-container-org0e868c6" class="outline-2">
<h2 id="org0e868c6"><span class="section-number-2">7</span> Direct Threaded Code</h2>
<div class="outline-text-2" id="text-7">
<p>
Now we'll get to the really crucial bit in understanding FORTH, so go and get a cup of tea
or coffee and settle down.  It's fair to say that if you don't understand this section, then you
won't "get" how FORTH works, and that would be a failure on my part for not explaining it well.
So if after reading this section a few times you don't understand it, please email me
(rich@annexia.org).
</p>

<p>
Let's talk first about what "threaded code" means.  Imagine a peculiar version of C where
you are only allowed to call functions without arguments.  (Don't worry for now that such a
language would be completely useless!)  So in our peculiar C, code would look like this:
</p>

<pre class="example" id="org30c8456">
f ()
{
  a ();
  b ();
  c ();
}
</pre>

<p>
and so on.  How would a function, say 'f' above, be compiled by a standard C compiler?
Probably into assembly code like this.  On the right hand side I've written the actual
i386 machine code.
</p>

<pre class="example" id="orgc63384c">
f:
  CALL a                        E8 08 00 00 00
  CALL b                        E8 1C 00 00 00
  CALL c                        E8 2C 00 00 00
  ; ignore the return from the function for now
</pre>

<p>
"<code>E8</code>" is the x86 machine code to "CALL" a function.  In the first 20 years of computing
memory was hideously expensive and we might have worried about the wasted space being used
by the repeated "E8" bytes.  We can save 20% in code size (and therefore, in expensive memory)
by compressing this into just:
</p>

<pre class="example" id="orgeb104e7">
08 00 00 00             Just the function addresses, without
1C 00 00 00             the CALL prefix.
2C 00 00 00
</pre>

<p>
On a 16-bit machine like the ones which originally ran FORTH the savings are even greater - 33%.
</p>

<p>
[Historical note: If the execution model that FORTH uses looks strange from the following
paragraphs, then it was motivated entirely by the need to save memory on early computers.
This code compression isn't so important now when our machines have more memory in their L1
caches than those early computers had in total, but the execution model still has some
useful properties].
</p>

<p>
Of course this code won't run directly on the CPU any more.  Instead we need to write an
interpreter which takes each set of bytes and calls it.
</p>

<p>
On an i386 machine it turns out that we can write this interpreter rather easily, in just
two assembly instructions which turn into just 3 bytes of machine code.  Let's store the
pointer to the next word to execute in the <code>%esi</code> register:
</p>

<pre class="example" id="org1cbb0f5">
        08 00 00 00     &lt;- We're executing this one now.  %esi is the _next_ one to execute.
%esi -&gt; 1C 00 00 00
        2C 00 00 00
</pre>

<p>
The all-important i386 instruction is called LODSL (or in Intel manuals, LODSW).  It does
two things.  Firstly it reads the memory at %esi into the accumulator (%eax).  Secondly it
increments %esi by 4 bytes.  So after LODSL, the situation now looks like this:
</p>

<pre class="example" id="orge3507d8">
        08 00 00 00     &lt;- We're still executing this one
        1C 00 00 00     &lt;- %eax now contains this address (0x0000001C)
%esi -&gt; 2C 00 00 00
</pre>

<p>
Now we just need to jump to the address in %eax.  This is again just a single x86 instruction
written <code>JMP *(%eax)</code>.  And after doing the jump, the situation looks like:
</p>

<pre class="example" id="org07acb71">
        08 00 00 00
        1C 00 00 00     &lt;- Now we're executing this subroutine.
%esi -&gt; 2C 00 00 00
</pre>

<p>
To make this work, each subroutine is followed by the two instructions '<code>LODSL; JMP *(%eax)</code>'
which literally make the jump to the next subroutine.
</p>

<p>
And that brings us to our first piece of actual code!  Well, it's a macro.
</p>


<div class="org-src-container">
<pre class="src src-asm">/* NEXT macro. */
	.macro NEXT
	lodsl
	jmp *(%eax)
	.endm
</pre>
</div>

<p>
The macro is called <code>NEXT</code>.  That's a FORTH-ism.  It expands to those two instructions.
</p>

<p>
Every FORTH primitive that we write has to be ended by <code>NEXT</code>.  Think of it kind of like
a return.
</p>

<p>
The above describes what is known as direct threaded code.
</p>

<p>
To sum up: We compress our function calls down to a list of addresses and use a somewhat
magical macro to act as a "jump to next function in the list".  We also use one register (<code>%esi</code>)
to act as a kind of instruction pointer, pointing to the next function in the list.
</p>

<p>
I'll just give you a hint of what is to come by saying that a FORTH definition such as:
</p>

<pre class="example" id="org76eb082">
: QUADRUPLE DOUBLE DOUBLE ;
</pre>

<p>
actually compiles (almost, not precisely but we'll see why in a moment) to a list of
function addresses for <code>DOUBLE</code>, <code>DOUBLE</code> and a special function called <code>EXIT</code> to finish off.
</p>

<p>
At this point, REALLY EAGLE-EYED ASSEMBLY EXPERTS are saying "JONES, YOU'VE MADE A MISTAKE!".
</p>

<p>
I lied about <code>JMP *(%eax)</code>.
</p>
</div>
</div>

<div id="outline-container-orga2283bf" class="outline-2">
<h2 id="orga2283bf"><span class="section-number-2">8</span> Indirect Threaded Code</h2>
<div class="outline-text-2" id="text-8">
<p>
It turns out that direct threaded code is interesting but only if you want to just execute
a list of functions written in assembly language.  So <code>QUADRUPLE</code> would work only if <code>DOUBLE</code>
was an assembly language function.  In the direct threaded code, <code>QUADRUPLE</code> would look like:
</p>

<pre class="example" id="orgdf8dde9">
        +------------------+
        | addr of DOUBLE  --------------------&gt; (assembly code to do the double)
        +------------------+                    NEXT
%esi -&gt; | addr of DOUBLE   |
        +------------------+
</pre>

<p>
We can add an extra indirection to allow us to run both words written in assembly language
(primitives written for speed) and words written in FORTH themselves as lists of addresses.
</p>

<p>
The extra indirection is the reason for the brackets in <code>JMP *(%eax)</code>.
</p>

<p>
Let's have a look at how <code>QUADRUPLE</code> and <code>DOUBLE</code> really look in FORTH:
</p>

<pre class="example" id="org814084b">
: QUADRUPLE DOUBLE DOUBLE ;

+------------------+
| codeword         |               : DOUBLE DUP + ;
+------------------+
| addr of DOUBLE  ---------------&gt; +------------------+
+------------------+               | codeword         |
| addr of DOUBLE   |               +------------------+
+------------------+               | addr of DUP   --------------&gt; +------------------+
| addr of EXIT     |               +------------------+            | codeword      -------+
+------------------+       %esi -&gt; | addr of +     --------+       +------------------+   |
                                   +------------------+    |       | assembly to    &lt;-----+
                                   | addr of EXIT     |    |       | implement DUP    |
                                   +------------------+    |       |    ..            |
                                                           |       |    ..            |
                                                           |       | NEXT             |
                                                           |       +------------------+
                                                           |
                                                           +-----&gt; +------------------+
                                                                   | codeword      -------+
                                                                   +------------------+   |
                                                                   | assembly to   &lt;------+
                                                                   | implement +      |
                                                                   |    ..            |
                                                                   |    ..            |
                                                                   | NEXT             |
                                                                   +------------------+
</pre>

<p>
This is the part where you may need an extra cup of tea/coffee/favourite caffeinated
beverage.  What has changed is that I've added an extra pointer to the beginning of
the definitions.  In FORTH this is sometimes called the "codeword".  The codeword is
a pointer to the interpreter to run the function.  For primitives written in
assembly language, the "interpreter" just points to the actual assembly code itself.
They don't need interpreting, they just run.
</p>

<p>
In words written in FORTH (like <code>QUADRUPLE</code> and <code>DOUBLE</code>), the codeword points to an interpreter
function.
</p>

<p>
I'll show you the interpreter function shortly, but let's recall our indirect
<code>JMP *(%eax)</code> with the "extra" brackets.  Take the case where we're executing <code>DOUBLE</code>
as shown, and <code>dup</code> has been called.  Note that <code>%esi</code> is pointing to the address of <code>+</code>
</p>

<p>
The assembly code for <code>DUP</code> eventually does a <code>NEXT</code>.  That:
</p>

<ol class="org-ol">
<li>reads the address of <code>+</code> into <code>%eax</code>            <code>%eax</code> points to the codeword of <code>+</code></li>
<li>increments <code>%esi</code> by 4</li>
<li><p>
jumps to the indirect <code>%eaxk                    jumps to the address in the codeword of =+</code>, ie. the assembly code to implement <code>+</code>
</p>

<pre class="example" id="orge9ef56a">
+------------------+
| codeword         |
+------------------+
| addr of DOUBLE  ---------------&gt; +------------------+
+------------------+               | codeword         |
| addr of DOUBLE   |               +------------------+
+------------------+               | addr of DUP   --------------&gt; +------------------+
| addr of EXIT     |               +------------------+            | codeword      -------+
+------------------+               | addr of +     --------+       +------------------+   |
                                   +------------------+    |       | assembly to    &lt;-----+
                           %esi -&gt; | addr of EXIT     |    |       | implement DUP    |
                                   +------------------+    |       |    ..            |
                                                           |       |    ..            |
                                                           |       | NEXT             |
                                                           |       +------------------+
                                                           |
                                                           +-----&gt; +------------------+
                                                                   | codeword      -------+
                                                                   +------------------+   |
                                                        now we're  | assembly to    &lt;-----+
                                                        executing  | implement +      |
                                                        this       |    ..            |
                                                        function   |    ..            |
                                                                   | NEXT             |
                                                                   +------------------+
</pre></li>
</ol>

<p>
So I hope that I've convinced you that <code>NEXT</code> does roughly what you'd expect.  This is
indirect threaded code.
</p>

<p>
I've glossed over four things.  I wonder if you can guess without reading on what they are?
</p>

<p>
.
.
.
</p>

<p>
My list of four things are: (1) What does "<code>EXIT</code>" do?  (2) which is related to (1) is how do
you call into a function, ie. how does <code>%esi</code> start off pointing at part of <code>QUADRUPLE</code>, but
then point at part of <code>DOUBLE</code>.  (3) What goes in the codeword for the words which are written
in FORTH?  (4) How do you compile a function which does anything except call other functions
ie. a function which contains a number like <code>: DOUBLE 2 * ;</code> ?
</p>
</div>
</div>

<div id="outline-container-orgc0ebaa2" class="outline-2">
<h2 id="orgc0ebaa2"><span class="section-number-2">9</span> The Interpreter and Return Stack</h2>
<div class="outline-text-2" id="text-9">
<p>
Going at these in no particular order, let's talk about issues (3) and (2), the interpreter
and the return stack.
</p>

<p>
Words which are defined in FORTH need a codeword which points to a little bit of code to
give them a "helping hand" in life.  They don't need much, but they do need what is known
as an "interpreter", although it doesn't really "interpret" in the same way that, say,
Java bytecode used to be interpreted (ie. slowly).  This interpreter just sets up a few
machine registers so that the word can then execute at full speed using the indirect
threaded model above.
</p>

<p>
One of the things that needs to happen when <code>QUADRUPLE</code> calls <code>DOUBLE</code> is that we save the old
<code>%esi</code> ("instruction pointer") and create a new one pointing to the first word in <code>DOUBLE</code>.
Because we will need to restore the old <code>%esi</code> at the end of <code>DOUBLE</code> (this is, after all, like
a function call), we will need a stack to store these "return addresses" (old values of <code>%esi</code>).
</p>

<p>
As you will have seen in the background documentation, FORTH has two stacks, an ordinary
stack for parameters, and a return stack which is a bit more mysterious.  But our return
stack is just the stack I talked about in the previous paragraph, used to save <code>%esi</code> when
calling from a FORTH word into another FORTH word.
</p>

<p>
In this FORTH, we are using the normal stack pointer (<code>%esp</code>) for the parameter stack.
We will use the i386's "other" stack pointer (<code>%ebp</code>, usually called the "frame pointer")
for our return stack.
</p>

<p>
I've got two macros which just wrap up the details of using <code>%ebp</code> for the return stack.
You use them as for example "<code>PUSHRSP %eax</code>" (push <code>%eax</code> on the return stack) or "<code>POPRSP %ebx</code>"
(pop top of return stack into <code>%ebx</code>).
</p>


<div class="org-src-container">
<pre class="src src-asm">/* Macros to deal with the return stack. */
	.macro PUSHRSP reg
	lea -4(%ebp),%ebp       // push reg on to return stack
	movl \reg,(%ebp)
	.endm

	.macro POPRSP reg
	mov (%ebp),\reg         // pop top of return stack to reg
	lea 4(%ebp),%ebp
	.endm
</pre>
</div>

<p>
And with that we can now talk about the interpreter.
</p>

<p>
In FORTH the interpreter function is often called <code>DOCOL</code> (I think it means "DO COLON" because
all FORTH definitions start with a colon, as in <code>: DOUBLE DUP + ;</code>
</p>

<p>
The "interpreter" (it's not really "interpreting") just needs to push the old <code>%esi</code> on the
stack and set <code>%esi</code> to the first word in the definition.  Remember that we jumped to the
function using <code>JMP *(%eax)</code>?  Well a consequence of that is that conveniently <code>%eax</code> contains
the address of this codeword, so just by adding 4 to it we get the address of the first
data word.  Finally after setting up <code>%esi</code>, it just does <code>NEXT</code> which causes that first word
to run.
</p>

<div class="org-src-container">
<pre class="src src-asm">/* DOCOL - the interpreter! */
	.text
	.align 4
DOCOL:
	PUSHRSP %esi            // push %esi on to the return stack
	addl $4,%eax            // %eax points to codeword, so make
	movl %eax,%esi          // %esi point to first data word
	NEXT
</pre>
</div>

<p>
Just to make this absolutely clear, let's see how <code>DOCOL</code> works when jumping from <code>QUADRUPLE</code>
into <code>DOUBLE</code>:
</p>

<pre class="example" id="org051078b">
        QUADRUPLE:
        +------------------+
        | codeword         |
        +------------------+               DOUBLE:
        | addr of DOUBLE  ---------------&gt; +------------------+
        +------------------+       %eax -&gt; | addr of DOCOL    |
%esi -&gt; | addr of DOUBLE   |               +------------------+
        +------------------+               | addr of DUP      |
        | addr of EXIT     |               +------------------+
        +------------------+               | etc.             |
</pre>

<p>
First, the call to <code>DOUBLE</code> calls <code>DOCOL</code> (the codeword of <code>DOUBLE</code>).  <code>DOCOL</code> does this:  It
pushes the old <code>%esi</code> on the return stack.  <code>%eax</code> points to the codeword of <code>DOUBLE</code>, so we
just add 4 on to it to get our new <code>%esi</code>:
</p>

<pre class="example" id="orgdde00ff">
                QUADRUPLE:
                +------------------+
                | codeword         |
                +------------------+               DOUBLE:
                | addr of DOUBLE  ---------------&gt; +------------------+
top of return   +------------------+       %eax -&gt; | addr of DOCOL    |
stack points -&gt; | addr of DOUBLE   |       + 4 =   +------------------+
                +------------------+       %esi -&gt; | addr of DUP      |
                | addr of EXIT     |               +------------------+
                +------------------+               | etc.             |
</pre>

<p>
Then we do <code>NEXT</code>, and because of the magic of threaded code that increments <code>%esi</code> again
and calls <code>DUP</code>.
</p>

<p>
Well, it seems to work.
</p>

<p>
One minor point here.  Because <code>DOCOL</code> is the first bit of assembly actually to be defined
in this file (the others were just macros), and because I usually compile this code with the
text segment starting at address 0, <code>DOCOL</code> has address 0.  So if you are disassembling the
code and see a word with a codeword of 0, you will immediately know that the word is
written in FORTH (it's not an assembler primitive) and so uses <code>DOCOL</code> as the interpreter.
</p>
</div>
</div>

<div id="outline-container-org943a4cf" class="outline-2">
<h2 id="org943a4cf"><span class="section-number-2">10</span> Starting Up</h2>
<div class="outline-text-2" id="text-10">
<p>
Now let's get down to nuts and bolts.  When we start the program we need to set up
a few things like the return stack.  But as soon as we can, we want to jump into FORTH
code (albeit much of the "early" FORTH code will still need to be written as
assembly language primitives).
</p>

<p>
This is what the set up code does.  Does a tiny bit of house-keeping, sets up the
separate return stack (NB: Linux gives us the ordinary parameter stack already), then
immediately jumps to a FORTH word called <code>QUIT</code>.  Despite its name, <code>QUIT</code> doesn't quit
anything.  It resets some internal state and starts reading and interpreting commands.
(The reason it is called <code>QUIT</code> is because you can call <code>QUIT</code> from your own FORTH code
to "quit" your program and go back to interpreting).
</p>

<div class="org-src-container">
<pre class="src src-asm">/* Assembler entry point. */
	.text
	.globl _start
_start:
	cld
	mov %esp,var_S0         // Save the initial data stack pointer in FORTH variable S0.
	mov $return_stack_top,%ebp // Initialise the return stack.
	call set_up_data_segment

	mov $cold_start,%esi    // Initialise interpreter.
	NEXT                    // Run interpreter!

	.section .rodata
cold_start:                     // High-level code without a codeword.
	.int QUIT
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb1aa2ba" class="outline-2">
<h2 id="orgb1aa2ba"><span class="section-number-2">11</span> Built-In Words</h2>
<div class="outline-text-2" id="text-11">
<p>
Remember our dictionary entries (headers)?  Let's bring those together with the codeword
and data words to see how <code>: DOUBLE DUP + ;</code> really looks in memory.
</p>

<pre class="example" id="orga439a6d">
  pointer to previous word
   ^
   |
+--|------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
| LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP        | +          | EXIT       |
+---------+---+---+---+---+---+---+---+---+------------+--|---------+------------+------------+
   ^       len                         pad  codeword      |
   |                                                      V
  LINK in next word                             points to codeword of DUP
</pre>

<p>
Initially we can't just write "<code>: DOUBLE DUP + ;</code>" (ie. that literal string) here because we
don't yet have anything to read the string, break it up at spaces, parse each word, etc. etc.
So instead we will have to define built-in words using the GNU assembler data constructors
(like <code>.int</code>, <code>.byte</code>, <code>.string</code>, <code>.ascii</code> and so on &#x2013; look them up in the gas info page if you are
unsure of them).
</p>

<p>
The long way would be:
</p>

<pre class="example" id="orgdbb5e1a">
        .int &lt;link to previous word&gt;
        .byte 6                 // len
        .ascii "DOUBLE"         // string
        .byte 0                 // padding
DOUBLE: .int DOCOL              // codeword
        .int DUP                // pointer to codeword of DUP
        .int PLUS               // pointer to codeword of +
        .int EXIT               // pointer to codeword of EXIT
</pre>

<p>
That's going to get quite tedious rather quickly, so here I define an assembler macro
so that I can just write:
</p>

<pre class="example" id="orgd5bd351">
defword "DOUBLE",6,,DOUBLE
.int DUP,PLUS,EXIT
</pre>

<p>
and I'll get exactly the same effect.
</p>

<p>
Don't worry too much about the exact implementation details of this macro - it's complicated!
</p>


<div class="org-src-container">
<pre class="src src-asm">/* Flags - these are discussed later. */
	.set F_IMMED,0x80
	.set F_HIDDEN,0x20
	.set F_LENMASK,0x1f     // length mask

	// Store the chain of links.
	.set link,0

	.macro defword name, namelen, flags=0, label
	.section .rodata
	.align 4
	.globl name_\label
name_\label :
	.int link               // link
	.set link,name_\label
	.byte \flags+\namelen   // flags + length byte
	.ascii "\name"          // the name
	.align 4                // padding to next 4 byte boundary
	.globl \label
\label :
	.int DOCOL              // codeword - the interpreter
	// list of word pointers follow
	.endm
</pre>
</div>

<p>
Similarly I want a way to write words written in assembly language.  There will be quite a few
of these to start with because, well, everything has to start in assembly before there's
enough "infrastructure" to be able to start writing FORTH words, but also I want to define
some common FORTH words in assembly language for speed, even though I could write them in FORTH.
</p>

<p>
This is what <code>DUP</code> looks like in memory:
</p>

<pre class="example" id="orga4aefac">
  pointer to previous word
   ^
   |
+--|------+---+---+---+---+------------+
| LINK    | 3 | D | U | P | code_DUP ---------------------&gt; points to the assembly
+---------+---+---+---+---+------------+                    code used to write DUP,
   ^       len              codeword                        which ends with NEXT.
   |
  LINK in next word
</pre>

<p>
Again, for brevity in writing the header I'm going to write an assembler macro called defcode.
As with defword above, don't worry about the complicated details of the macro.
</p>


<div class="org-src-container">
<pre class="src src-asm">	.macro defcode name, namelen, flags=0, label
	.section .rodata
	.align 4
	.globl name_\label
name_\label :
	.int link               // link
	.set link,name_\label
	.byte \flags+\namelen   // flags + length byte
	.ascii "\name"          // the name
	.align 4                // padding to next 4 byte boundary
	.globl \label
\label :
	.int code_\label        // codeword
	.text
	//.align 4
	.globl code_\label
code_\label :                   // assembler code follows
	.endm
</pre>
</div>


<p>
Now some easy FORTH primitives.  These are written in assembly for speed.  If you understand
i386 assembly language then it is worth reading these.  However if you don't understand assembly
you can skip the details.
</p>


<div class="org-src-container">
<pre class="src src-asm">	defcode "DROP",4,,DROP
	pop %eax                // drop top of stack
	NEXT

	defcode "SWAP",4,,SWAP
	pop %eax                // swap top two elements on stack
	pop %ebx
	push %eax
	push %ebx
	NEXT

	defcode "DUP",3,,DUP
	mov (%esp),%eax         // duplicate top of stack
	push %eax
	NEXT

	defcode "OVER",4,,OVER
	mov 4(%esp),%eax        // get the second element of stack
	push %eax               // and push it on top
	NEXT

	defcode "ROT",3,,ROT
	pop %eax
	pop %ebx
	pop %ecx
	push %ebx
	push %eax
	push %ecx
	NEXT

	defcode "-ROT",4,,NROT
	pop %eax
	pop %ebx
	pop %ecx
	push %eax
	push %ecx
	push %ebx
	NEXT

	defcode "2DROP",5,,TWODROP // drop top two elements of stack
	pop %eax
	pop %eax
	NEXT

	defcode "2DUP",4,,TWODUP // duplicate top two elements of stack
	mov (%esp),%eax
	mov 4(%esp),%ebx
	push %ebx
	push %eax
	NEXT

	defcode "2SWAP",5,,TWOSWAP // swap top two pairs of elements of stack
	pop %eax
	pop %ebx
	pop %ecx
	pop %edx
	push %ebx
	push %eax
	push %edx
	push %ecx
	NEXT

	defcode "?DUP",4,,QDUP  // duplicate top of stack if non-zero
	movl (%esp),%eax
	test %eax,%eax
	jz 1f
	push %eax
1:      NEXT

	defcode "1+",2,,INCR
	incl (%esp)             // increment top of stack
	NEXT

	defcode "1-",2,,DECR
	decl (%esp)             // decrement top of stack
	NEXT

	defcode "4+",2,,INCR4
	addl $4,(%esp)          // add 4 to top of stack
	NEXT

	defcode "4-",2,,DECR4
	subl $4,(%esp)          // subtract 4 from top of stack
	NEXT

	defcode "+",1,,ADD
	pop %eax                // get top of stack
	addl %eax,(%esp)        // and add it to next word on stack
	NEXT

	defcode "-",1,,SUB
	pop %eax                // get top of stack
	subl %eax,(%esp)        // and subtract it from next word on stack
	NEXT

	defcode "*",1,,MUL
	pop %eax
	pop %ebx
	imull %ebx,%eax
	push %eax               // ignore overflow
	NEXT
</pre>
</div>


<p>
In this FORTH, only <code>/MOD</code> is primitive.  Later we will define the <code>/</code> and <code>MOD</code> words in
terms of the primitive <code>/MOD</code>.  The design of the i386 assembly instruction <code>idiv</code> which
leaves both quotient and remainder makes this the obvious choice.
</p>


<div class="org-src-container">
<pre class="src src-asm">defcode "/MOD",4,,DIVMOD
xor %edx,%edx
pop %ebx
pop %eax
idivl %ebx
push %edx               // push remainder
push %eax               // push quotient
NEXT
</pre>
</div>

<p>
Lots of comparison operations like =, &lt;, &gt;, etc..
</p>

<p>
ANS FORTH says that the comparison words should return all (binary) 1's for
TRUE and all 0's for FALSE.  However this is a bit of a strange convention
so this FORTH breaks it and returns the more normal (for C programmers &#x2026;)
1 meaning TRUE and 0 meaning FALSE.
</p>

<div class="org-src-container">
<pre class="src src-asm">defcode "=",1,,EQU      // top two words are equal?
pop %eax
pop %ebx
cmp %ebx,%eax
sete %al
movzbl %al,%eax
pushl %eax
NEXT

defcode "&lt;&gt;",2,,NEQU    // top two words are not equal?
pop %eax
pop %ebx
cmp %ebx,%eax
setne %al
movzbl %al,%eax
pushl %eax
NEXT

defcode "&lt;",1,,LT
pop %eax
pop %ebx
cmp %eax,%ebx
setl %al
movzbl %al,%eax
pushl %eax
NEXT

defcode "&gt;",1,,GT
pop %eax
pop %ebx
cmp %eax,%ebx
setg %al
movzbl %al,%eax
pushl %eax
NEXT

defcode "&lt;=",2,,LE
pop %eax
pop %ebx
cmp %eax,%ebx
setle %al
movzbl %al,%eax
pushl %eax
NEXT

defcode "&gt;=",2,,GE
pop %eax
pop %ebx
cmp %eax,%ebx
setge %al
movzbl %al,%eax
pushl %eax
NEXT

defcode "0=",2,,ZEQU    // top of stack equals 0?
pop %eax
test %eax,%eax
setz %al
movzbl %al,%eax
pushl %eax
NEXT

defcode "0&lt;&gt;",3,,ZNEQU  // top of stack not 0?
pop %eax
test %eax,%eax
setnz %al
movzbl %al,%eax
pushl %eax
NEXT

defcode "0&lt;",2,,ZLT     // comparisons with 0
pop %eax
test %eax,%eax
setl %al
movzbl %al,%eax
pushl %eax
NEXT

defcode "0&gt;",2,,ZGT
pop %eax
test %eax,%eax
setg %al
movzbl %al,%eax
pushl %eax
NEXT

defcode "0&lt;=",3,,ZLE
pop %eax
test %eax,%eax
setle %al
movzbl %al,%eax
pushl %eax
NEXT

defcode "0&gt;=",3,,ZGE
pop %eax
test %eax,%eax
setge %al
movzbl %al,%eax
pushl %eax
NEXT

defcode "AND",3,,AND    // bitwise AND
pop %eax
andl %eax,(%esp)
NEXT

defcode "OR",2,,OR      // bitwise OR
pop %eax
orl %eax,(%esp)
NEXT

defcode "XOR",3,,XOR    // bitwise XOR
pop %eax
xorl %eax,(%esp)
NEXT

defcode "INVERT",6,,INVERT // this is the FORTH bitwise "NOT" function (cf. NEGATE and NOT)
notl (%esp)
NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-org60b6de2" class="outline-2">
<h2 id="org60b6de2"><span class="section-number-2">12</span> Returning From Forth Words</h2>
<div class="outline-text-2" id="text-12">
<p>
Time to talk about what happens when we <code>EXIT</code> a function.  In this diagram <code>QUADRUPLE</code> has called
<code>DOUBLE</code>, and <code>DOUBLE</code> is about to exit (look at where %esi is pointing):
</p>

<pre class="example" id="org6a26719">
QUADRUPLE
+------------------+
| codeword         |
+------------------+               DOUBLE
| addr of DOUBLE  ---------------&gt; +------------------+
+------------------+               | codeword         |
| addr of DOUBLE   |               +------------------+
+------------------+               | addr of DUP      |
| addr of EXIT     |               +------------------+
+------------------+               | addr of +        |
                                   +------------------+
                           %esi -&gt; | addr of EXIT     |
                                   +------------------+
</pre>

<p>
What happens when the + function does <code>NEXT</code>?  Well, the following code is executed.
</p>

<pre class="example" id="org5011b0c">
defcode "EXIT",4,,EXIT
POPRSP %esi             // pop return stack into %esi
NEXT
</pre>

<p>
<code>EXIT</code> gets the old <code>%esi</code> which we saved from before on the return stack, and puts it in <code>%esi</code>.
So after this (but just before <code>NEXT</code>) we get:
</p>

<pre class="example" id="orgfed8e0c">
        QUADRUPLE
        +------------------+
        | codeword         |
        +------------------+               DOUBLE
        | addr of DOUBLE  ---------------&gt; +------------------+
        +------------------+               | codeword         |
%esi -&gt; | addr of DOUBLE   |               +------------------+
        +------------------+               | addr of DUP      |
        | addr of EXIT     |               +------------------+
        +------------------+               | addr of +        |
                                           +------------------+
                                           | addr of EXIT     |
                                           +------------------+
</pre>

<p>
And <code>NEXT</code> just completes the job by, well, in this case just by calling <code>DOUBLE</code> again :-)
</p>
</div>
</div>

<div id="outline-container-org1125940" class="outline-2">
<h2 id="org1125940"><span class="section-number-2">13</span> Literals</h2>
<div class="outline-text-2" id="text-13">
<p>
The final point I "glossed over" before was how to deal with functions that do anything
apart from calling other functions.  For example, suppose that <code>DOUBLE</code> was defined like this:
</p>

<pre class="example" id="orgb210232">
: DOUBLE 2 * ;
</pre>

<p>
It does the same thing, but how do we compile it since it contains the literal 2?  One way
would be to have a function called "2" (which you'd have to write in assembler), but you'd need
a function for every single literal that you wanted to use.
</p>

<p>
FORTH solves this by compiling the function using a special word called <code>LIT</code>:
</p>

<pre class="example" id="org33a89cb">
+---------------------------+-------+-------+-------+-------+-------+
| (usual header of DOUBLE)  | DOCOL | LIT   | 2     | *     | EXIT  |
+---------------------------+-------+-------+-------+-------+-------+
</pre>

<p>
<code>LIT</code> is executed in the normal way, but what it does next is definitely not normal.  It
looks at <code>%esi</code> (which now points to the number 2), grabs it, pushes it on the stack, then
manipulates <code>%esi</code> in order to skip the number as if it had never been there.
</p>

<p>
What's neat is that the whole grab/manipulate can be done using a single byte single
i386 instruction, our old friend <code>LODSL</code>.  Rather than me drawing more ASCII-art diagrams,
see if you can find out how <code>LIT</code> works:
</p>

<div class="org-src-container">
<pre class="src src-asm">defcode "LIT",3,,LIT
// %esi points to the next command, but in this case it points to the next
// literal 32 bit integer.  Get that literal into %eax and increment %esi.
// On x86, it's a convenient single byte instruction!  (cf. NEXT macro)
lodsl
push %eax               // push the literal number on to stack
NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-org8292166" class="outline-2">
<h2 id="org8292166"><span class="section-number-2">14</span> Memory</h2>
<div class="outline-text-2" id="text-14">
<p>
An important point about FORTH is that it gives you direct access to the lowest levels
of the machine.  Manipulating memory directly is done frequently in FORTH, and these are
the primitive words for doing it.
</p>

<div class="org-src-container">
<pre class="src src-asm">defcode "!",1,,STORE
pop %ebx                // address to store at
pop %eax                // data to store there
mov %eax,(%ebx)         // store it
NEXT

defcode "@",1,,FETCH
pop %ebx                // address to fetch
mov (%ebx),%eax         // fetch it
push %eax               // push value onto stack
NEXT

defcode "+!",2,,ADDSTORE
pop %ebx                // address
pop %eax                // the amount to add
addl %eax,(%ebx)        // add it
NEXT

defcode "-!",2,,SUBSTORE
pop %ebx                // address
pop %eax                // the amount to subtract
subl %eax,(%ebx)        // add it
NEXT
</pre>
</div>

<p>
<code>!</code> and <code>@</code> (<code>STORE</code> and <code>FETCHk) store 32-bit words.  It's also useful to be able to read and write bytes
        so we also define standard words =C@</code> and <code>C!</code>.
</p>

<p>
Byte-oriented operations only work on architectures which permit them (i386 is one of those).
</p>


<div class="org-src-container">
<pre class="src src-asm">	defcode "C!",2,,STOREBYTE
	pop %ebx                // address to store at
	pop %eax                // data to store there
	movb %al,(%ebx)         // store it
	NEXT

	defcode "C@",2,,FETCHBYTE
	pop %ebx                // address to fetch
	xor %eax,%eax
	movb (%ebx),%al         // fetch it
	push %eax               // push value onto stack
	NEXT

/* C@C! is a useful byte copy primitive. */
	defcode "C@C!",4,,CCOPY
	movl 4(%esp),%ebx       // source address
	movb (%ebx),%al         // get source character
	pop %edi                // destination address
	stosb                   // copy to destination
	push %edi               // increment destination address
	incl 4(%esp)            // increment source address
	NEXT

/* and CMOVE is a block copy operation. */
	defcode "CMOVE",5,,CMOVE
	mov %esi,%edx           // preserve %esi
	pop %ecx                // length
	pop %edi                // destination address
	pop %esi                // source address
	rep movsb               // copy source to destination
	mov %edx,%esi           // restore %esi
	NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfbdf3a0" class="outline-2">
<h2 id="orgfbdf3a0"><span class="section-number-2">15</span> Built-In Variables</h2>
<div class="outline-text-2" id="text-15">
<p>
These are some built-in variables and related standard FORTH words.  Of these, the only one that we
have discussed so far was <code>LATEST</code>, which points to the last (most recently defined) word in the
FORTH dictionary.  <code>LATEST</code> is also a FORTH word which pushes the address of <code>LATEST</code> (the variable)
on to the stack, so you can read or write it using <code>@</code> and <code>!</code> operators.  For example, to print
the current value of <code>LATEST</code> (and this can apply to any FORTH variable) you would do:
</p>

<pre class="example" id="org9a92d90">
LATEST @ . CR
</pre>

<p>
To make defining variables shorter, I'm using a macro called defvar, similar to defword and
defcode above.  (In fact the defvar macro uses defcode to do the dictionary header).
</p>

<div class="org-src-container">
<pre class="src src-asm">	.macro defvar name, namelen, flags=0, label, initial=0
	defcode \name,\namelen,\flags,\label
	push $var_\name
	NEXT
	.data
	.align 4
var_\name :
	.int \initial
	.endm
</pre>
</div>

<p>
The built-in variables are:
</p>

<ul class="org-ul">
<li><code>STATE</code>           Is the interpreter executing code (0) or compiling a word (non-zero)?</li>
<li><code>LATEST</code>          Points to the latest (most recently defined) word in the dictionary.</li>
<li><code>HERE</code>            Points to the next free byte of memory.  When compiling, compiled words go here.</li>
<li><code>S0</code>              Stores the address of the top of the parameter stack.</li>
<li><code>BASE</code>            The current base for printing and reading numbers.</li>
</ul>


<div class="org-src-container">
<pre class="src src-asm">defvar "STATE",5,,STATE
defvar "HERE",4,,HERE
defvar "LATEST",6,,LATEST,name_SYSCALL0 // SYSCALL0 must be last in built-in dictionary
defvar "S0",2,,SZ
defvar "BASE",4,,BASE,10
</pre>
</div>
</div>
</div>

<div id="outline-container-org713b196" class="outline-2">
<h2 id="org713b196"><span class="section-number-2">16</span> Built-In Constants</h2>
<div class="outline-text-2" id="text-16">
<p>
It's also useful to expose a few constants to FORTH.  When the word is executed it pushes a
constant value on the stack.
</p>

<p>
The built-in constants are:
</p>

<ul class="org-ul">
<li><code>VERSION</code>         Is the current version of this FORTH.</li>
<li><code>R0</code>              The address of the top of the return stack.</li>
<li><code>DOCOL</code>           Pointer to DOCOL.</li>
<li><code>F_IMMED</code>         The IMMEDIATE flag's actual value.</li>
<li><code>F_HIDDEN</code>        The HIDDEN flag's actual value.</li>
<li><code>F_LENMASK</code>       The length mask in the flags/len byte.</li>
<li><code>SYS_*</code>           and the numeric codes of various Linux syscalls (from &lt;asm/unistd.h&gt;)</li>
</ul>

<div class="org-src-container">
<pre class="src src-asm">#include &lt;asm-i386/unistd.h&gt;

	.macro defconst name, namelen, flags=0, label, value
	defcode \name,\namelen,\flags,\label
	push $\value
	NEXT
	.endm

	defconst "VERSION",7,,VERSION,JONES_VERSION
	defconst "R0",2,,RZ,return_stack_top
	defconst "DOCOL",5,,__DOCOL,DOCOL
	defconst "F_IMMED",7,,__F_IMMED,F_IMMED
	defconst "F_HIDDEN",8,,__F_HIDDEN,F_HIDDEN
	defconst "F_LENMASK",9,,__F_LENMASK,F_LENMASK

	defconst "SYS_EXIT",8,,SYS_EXIT,__NR_exit
	defconst "SYS_OPEN",8,,SYS_OPEN,__NR_open
	defconst "SYS_CLOSE",9,,SYS_CLOSE,__NR_close
	defconst "SYS_READ",8,,SYS_READ,__NR_read
	defconst "SYS_WRITE",9,,SYS_WRITE,__NR_write
	defconst "SYS_CREAT",9,,SYS_CREAT,__NR_creat
	defconst "SYS_BRK",7,,SYS_BRK,__NR_brk

	defconst "O_RDONLY",8,,__O_RDONLY,0
	defconst "O_WRONLY",8,,__O_WRONLY,1
	defconst "O_RDWR",6,,__O_RDWR,2
	defconst "O_CREAT",7,,__O_CREAT,0100
	defconst "O_EXCL",6,,__O_EXCL,0200
	defconst "O_TRUNC",7,,__O_TRUNC,01000
	defconst "O_APPEND",8,,__O_APPEND,02000
	defconst "O_NONBLOCK",10,,__O_NONBLOCK,04000
</pre>
</div>
</div>
</div>

<div id="outline-container-orged975fe" class="outline-2">
<h2 id="orged975fe"><span class="section-number-2">17</span> Return Stack</h2>
<div class="outline-text-2" id="text-17">
<p>
These words allow you to access the return stack.  Recall that the register %ebp always points to
the top of the return stack.
</p>


<div class="org-src-container">
<pre class="src src-asm">defcode "&gt;R",2,,TOR
pop %eax                // pop parameter stack into %eax
PUSHRSP %eax            // push it on to the return stack
NEXT

defcode "R&gt;",2,,FROMR
POPRSP %eax             // pop return stack on to %eax
push %eax               // and push on to parameter stack
NEXT

defcode "RSP@",4,,RSPFETCH
push %ebp
NEXT

defcode "RSP!",4,,RSPSTORE
pop %ebp
NEXT

defcode "RDROP",5,,RDROP
addl $4,%ebp            // pop return stack and throw away
NEXT
</pre>
</div>
</div>
</div>


<div id="outline-container-org63509cd" class="outline-2">
<h2 id="org63509cd"><span class="section-number-2">18</span> Parameter (Data) Stack</h2>
<div class="outline-text-2" id="text-18">
<p>
These functions allow you to manipulate the parameter stack.  Recall that Linux sets up the parameter
stack for us, and it is accessed through <code>%esp</code>.
</p>


<div class="org-src-container">
<pre class="src src-asm">defcode "DSP@",4,,DSPFETCH
mov %esp,%eax
push %eax
NEXT

defcode "DSP!",4,,DSPSTORE
pop %esp
NEXT
</pre>
</div>
</div>
</div>

<div id="outline-container-org6d31b5a" class="outline-2">
<h2 id="org6d31b5a"><span class="section-number-2">19</span> Input and Output</h2>
<div class="outline-text-2" id="text-19">
<p>
These are our first really meaty/complicated FORTH primitives.  I have chosen to write them in
assembler, but surprisingly in "real" FORTH implementations these are often written in terms
of more fundamental FORTH primitives.  I chose to avoid that because I think that just obscures
the implementation.  After all, you may not understand assembler but you can just think of it
as an opaque block of code that does what it says.
</p>

<p>
Let's discuss input first.
</p>

<p>
The FORTH word KEY reads the next byte from stdin (and pushes it on the parameter stack).
So if KEY is called and someone hits the space key, then the number 32 (ASCII code of space)
is pushed on the stack.
</p>

<p>
In FORTH there is no distinction between reading code and reading input.  We might be reading
and compiling code, we might be reading words to execute, we might be asking for the user
to type their name &#x2013; ultimately it all comes in through KEY.
</p>

<p>
The implementation of KEY uses an input buffer of a certain size (defined at the end of this
file).  It calls the Linux read(2) system call to fill this buffer and tracks its position
in the buffer using a couple of variables, and if it runs out of input buffer then it refills
it automatically.  The other thing that KEY does is if it detects that stdin has closed, it
exits the program, which is why when you hit ^D the FORTH system cleanly exits.
</p>

<pre class="example" id="org41ea4d6">
buffer                           bufftop
   |                                |
   V                                V
   +-------------------------------+--------------------------------------+
   | INPUT READ FROM STDIN ....... | unused part of the buffer            |
   +-------------------------------+--------------------------------------+
                     ^
                     |
                  currkey (next character to read)

   &lt;---------------------- BUFFER_SIZE (4096 bytes) ----------------------&gt;
</pre>


<div class="org-src-container">
<pre class="src src-asm">	defcode "KEY",3,,KEY
	call _KEY
	push %eax               // push return value on stack
	NEXT
_KEY:
	mov (currkey),%ebx
	cmp (bufftop),%ebx
	jge 1f                  // exhausted the input buffer?
	xor %eax,%eax
	mov (%ebx),%al          // get next key from input buffer
	inc %ebx
	mov %ebx,(currkey)      // increment currkey
	ret

1:      // Out of input; use read(2) to fetch more input from stdin.
	xor %ebx,%ebx           // 1st param: stdin
	mov $buffer,%ecx        // 2nd param: buffer
	mov %ecx,currkey
	mov $BUFFER_SIZE,%edx   // 3rd param: max length
	mov $__NR_read,%eax     // syscall: read
	int $0x80
	test %eax,%eax          // If %eax &lt;= 0, then exit.
	jbe 2f
	addl %eax,%ecx          // buffer+%eax = bufftop
	mov %ecx,bufftop
	jmp _KEY

2:      // Error or end of input: exit the program.
	xor %ebx,%ebx
	mov $__NR_exit,%eax     // syscall: exit
	int $0x80

	.data
	.align 4
currkey:
	.int buffer             // Current place in input buffer (next character to read).
bufftop:
	.int buffer             // Last valid data in input buffer + 1.

/*
	By contrast, output is much simpler.  The FORTH word EMIT writes out a single byte to stdout.
	This implementation just uses the write system call.  No attempt is made to buffer output, but
	it would be a good exercise to add it.
*/

	defcode "EMIT",4,,EMIT
	pop %eax
	call _EMIT
	NEXT
_EMIT:
	mov $1,%ebx             // 1st param: stdout

	// write needs the address of the byte to write
	mov %al,emit_scratch
	mov $emit_scratch,%ecx  // 2nd param: address

	mov $1,%edx             // 3rd param: nbytes = 1

	mov $__NR_write,%eax    // write syscall
	int $0x80
	ret

	.data                   // NB: easier to fit in the .data section
emit_scratch:
	.space 1                // scratch used by EMIT
</pre>
</div>


<p>
Back to input, WORD is a FORTH word which reads the next full word of input.
</p>

<p>
What it does in detail is that it first skips any blanks (spaces, tabs, newlines and so on).
Then it calls KEY to read characters into an internal buffer until it hits a blank.  Then it
calculates the length of the word it read and returns the address and the length as
two words on the stack (with the length at the top of stack).
</p>

<p>
Notice that WORD has a single internal buffer which it overwrites each time (rather like
a static C string).  Also notice that WORD's internal buffer is just 32 bytes long and
there is NO checking for overflow.  31 bytes happens to be the maximum length of a
FORTH word that we support, and that is what WORD is used for: to read FORTH words when
we are compiling and executing code.  The returned strings are not NUL-terminated.
</p>

<p>
Start address+length is the normal way to represent strings in FORTH (not ending in an
ASCII NUL character as in C), and so FORTH strings can contain any character including NULs
and can be any length.
</p>

<p>
WORD is not suitable for just reading strings (eg. user input) because of all the above
peculiarities and limitations.
</p>

<p>
Note that when executing, you'll see:
WORD FOO
which puts "FOO" and length 3 on the stack, but when compiling:
</p>
<pre class="example">
BAR WORD FOO ;
</pre>

<p>
is an error (or at least it doesn't do what you might expect).  Later we'll talk about compiling
and immediate mode, and you'll understand why.
</p>


<div class="org-src-container">
<pre class="src src-asm">	defcode "WORD",4,,WORD
	call _WORD
	push %edi               // push base address
	push %ecx               // push length
	NEXT

_WORD:
	/* Search for first non-blank character.  Also skip \ comments. */
1:
	call _KEY               // get next key, returned in %eax
	cmpb $'\\',%al          // start of a comment?
	je 3f                   // if so, skip the comment
	cmpb $' ',%al
	jbe 1b                  // if so, keep looking

	/* Search for the end of the word, storing chars as we go. */
	mov $word_buffer,%edi   // pointer to return buffer
2:
	stosb                   // add character to return buffer
	call _KEY               // get next key, returned in %al
	cmpb $' ',%al           // is blank?
	ja 2b                   // if not, keep looping

	/* Return the word (well, the static buffer) and length. */
	sub $word_buffer,%edi
	mov %edi,%ecx           // return length of the word
	mov $word_buffer,%edi   // return address of the word
	ret

	/* Code to skip \ comments to end of the current line. */
3:
	call _KEY
	cmpb $'\n',%al          // end of line yet?
	jne 3b
	jmp 1b

	.data                   // NB: easier to fit in the .data section
	// A static buffer where WORD returns.  Subsequent calls
	// overwrite this buffer.  Maximum word length is 32 chars.
word_buffer:
	.space 32
</pre>
</div>


<p>
As well as reading in words we'll need to read in numbers and for that we are using a function
called NUMBER.  This parses a numeric string such as one returned by WORD and pushes the
number on the parameter stack.
</p>

<p>
The function uses the variable BASE as the base (radix) for conversion, so for example if
BASE is 2 then we expect a binary number.  Normally BASE is 10.
</p>

<p>
If the word starts with a '-' character then the returned value is negative.
</p>

<p>
If the string can't be parsed as a number (or contains characters outside the current BASE)
then we need to return an error indication.  So NUMBER actually returns two items on the stack.
At the top of stack we return the number of unconverted characters (ie. if 0 then all characters
were converted, so there is no error).  Second from top of stack is the parsed number or a
partial value if there was an error.
</p>

<div class="org-src-container">
<pre class="src src-asm">	defcode "NUMBER",6,,NUMBER
	pop %ecx                // length of string
	pop %edi                // start address of string
	call _NUMBER
	push %eax               // parsed number
	push %ecx               // number of unparsed characters (0 = no error)
	NEXT

_NUMBER:
	xor %eax,%eax
	xor %ebx,%ebx

	test %ecx,%ecx          // trying to parse a zero-length string is an error, but will return 0.
	jz 5f

	movl var_BASE,%edx      // get BASE (in %dl)

	// Check if first character is '-'.
	movb (%edi),%bl         // %bl = first character in string
	inc %edi
	push %eax               // push 0 on stack
	cmpb $'-',%bl           // negative number?
	jnz 2f
	pop %eax
	push %ebx               // push &lt;&gt; 0 on stack, indicating negative
	dec %ecx
	jnz 1f
	pop %ebx                // error: string is only '-'.
	movl $1,%ecx
	ret

	// Loop reading digits.
1:      imull %edx,%eax         // %eax *= BASE
	movb (%edi),%bl         // %bl = next character in string
	inc %edi

	// Convert 0-9, A-Z to a number 0-35.
2:      subb $'0',%bl           // &lt; '0'?
	jb 4f
	cmp $10,%bl             // &lt;= '9'?
	jb 3f
	subb $17,%bl            // &lt; 'A'? (17 is 'A'-'0')
	jb 4f
	addb $10,%bl

3:      cmp %dl,%bl             // &gt;= BASE?
	jge 4f

	// OK, so add it to %eax and loop.
	add %ebx,%eax
	dec %ecx
	jnz 1b

	// Negate the result if first character was '-' (saved on the stack).
4:      pop %ebx
	test %ebx,%ebx
	jz 5f
	neg %eax

5:      ret
</pre>
</div>
</div>
</div>


<div id="outline-container-org0d31f54" class="outline-2">
<h2 id="org0d31f54"><span class="section-number-2">20</span> Dictionary Look Ups</h2>
<div class="outline-text-2" id="text-20">
<p>
We're building up to our prelude on how FORTH code is compiled, but first we need yet more infrastructure.
</p>

<p>
The FORTH word FIND takes a string (a word as parsed by WORD &#x2013; see above) and looks it up in the
dictionary.  What it actually returns is the address of the dictionary header, if it finds it,
or 0 if it didn't.
</p>

<p>
So if DOUBLE is defined in the dictionary, then WORD DOUBLE FIND returns the following pointer:
</p>

<pre class="example" id="org6dba636">
pointer to this
    |
    |
    V
    +---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
    | LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP        | +          | EXIT       |
    +---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
</pre>

<p>
See also &gt;CFA and &gt;DFA.
</p>

<p>
FIND doesn't find dictionary entries which are flagged as HIDDEN.  See below for why.
</p>


<div class="org-src-container">
<pre class="src src-asm">	defcode "FIND",4,,FIND
	pop %ecx                // %ecx = length
	pop %edi                // %edi = address
	call _FIND
	push %eax               // %eax = address of dictionary entry (or NULL)
	NEXT

_FIND:
	push %esi               // Save %esi so we can use it in string comparison.

	// Now we start searching backwards through the dictionary for this word.
	mov var_LATEST,%edx     // LATEST points to name header of the latest word in the dictionary
1:      test %edx,%edx          // NULL pointer?  (end of the linked list)
	je 4f

	// Compare the length expected and the length of the word.
	// Note that if the F_HIDDEN flag is set on the word, then by a bit of trickery
	// this won't pick the word (the length will appear to be wrong).
	xor %eax,%eax
	movb 4(%edx),%al        // %al = flags+length field
	andb $(F_HIDDEN|F_LENMASK),%al // %al = name length
	cmpb %cl,%al            // Length is the same?
	jne 2f

	// Compare the strings in detail.
	push %ecx               // Save the length
	push %edi               // Save the address (repe cmpsb will move this pointer)
	lea 5(%edx),%esi        // Dictionary string we are checking against.
	repe cmpsb              // Compare the strings.
	pop %edi
	pop %ecx
	jne 2f                  // Not the same.

	// The strings are the same - return the header pointer in %eax
	pop %esi
	mov %edx,%eax
	ret

2:      mov (%edx),%edx         // Move back through the link field to the previous word
	jmp 1b                  // .. and loop.

4:      // Not found.
	pop %esi
	xor %eax,%eax           // Return zero to indicate not found.
	ret
</pre>
</div>

<p>
FIND returns the dictionary pointer, but when compiling we need the codeword pointer (recall
that FORTH definitions are compiled into lists of codeword pointers).  The standard FORTH
word &gt;CFA turns a dictionary pointer into a codeword pointer.
</p>

<p>
The example below shows the result of:
</p>

<pre class="example" id="org552904d">
        WORD DOUBLE FIND &gt;CFA

FIND returns a pointer to this
|                               &gt;CFA converts it to a pointer to this
|                                          |
V                                          V
+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
| LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP        | +          | EXIT       |
+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
                                           codeword
</pre>

<p>
Notes:
</p>

<p>
Because names vary in length, this isn't just a simple increment.
</p>

<p>
In this FORTH you cannot easily turn a codeword pointer back into a dictionary entry pointer, but
that is not true in most FORTH implementations where they store a back pointer in the definition
(with an obvious memory/complexity cost).  The reason they do this is that it is useful to be
able to go backwards (codeword -&gt; dictionary entry) in order to decompile FORTH definitions
quickly.
</p>

<p>
What does CFA stand for?  My best guess is "Code Field Address".
</p>


<div class="org-src-container">
<pre class="src src-asm">	defcode "&gt;CFA",4,,TCFA
	pop %edi
	call _TCFA
	push %edi
	NEXT
_TCFA:
	xor %eax,%eax
	add $4,%edi             // Skip link pointer.
	movb (%edi),%al         // Load flags+len into %al.
	inc %edi                // Skip flags+len byte.
	andb $F_LENMASK,%al     // Just the length, not the flags.
	add %eax,%edi           // Skip the name.
	addl $3,%edi            // The codeword is 4-byte aligned.
	andl $~3,%edi
	ret
</pre>
</div>

<p>
Related to &gt;CFA is &gt;DFA which takes a dictionary entry address as returned by FIND and
returns a pointer to the first data field.
</p>

<pre class="example" id="org6c512c7">
FIND returns a pointer to this
|                               &gt;CFA converts it to a pointer to this
|                                          |
|                                          |    &gt;DFA converts it to a pointer to this
|                                          |             |
V                                          V             V
+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
| LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP        | +          | EXIT       |
+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
                                           codeword
</pre>

<p>
(Note to those following the source of FIG-FORTH / ciforth: My &gt;DFA definition is
different from theirs, because they have an extra indirection).
</p>

<p>
You can see that &gt;DFA is easily defined in FORTH just by adding 4 to the result of &gt;CFA.
</p>


<div class="org-src-container">
<pre class="src src-asm">defword "&gt;DFA",4,,TDFA
.int TCFA               // &gt;CFA         (get code field address)
.int INCR4              // 4+           (add 4 to it to get to next word)
.int EXIT               // EXIT         (return from FORTH word)
</pre>
</div>
</div>
</div>


<div id="outline-container-org81c32ab" class="outline-2">
<h2 id="org81c32ab"><span class="section-number-2">21</span> Compiling</h2>
<div class="outline-text-2" id="text-21">
<p>
Now we'll talk about how FORTH compiles words.  Recall that a word definition looks like this:
</p>

<pre class="example" id="org86a85b4">
: DOUBLE DUP + ;
</pre>

<p>
and we have to turn this into:
</p>

<pre class="example" id="orgb4829e7">
  pointer to previous word
   ^
   |
+--|------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
| LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP        | +          | EXIT       |
+---------+---+---+---+---+---+---+---+---+------------+--|---------+------------+------------+
   ^       len                         pad  codeword      |
   |                                                      V
  LATEST points here                            points to codeword of DUP
</pre>

<p>
There are several problems to solve.  Where to put the new word?  How do we read words?  How
do we define the words : (COLON) and ; (SEMICOLON)?
</p>

<p>
FORTH solves this rather elegantly and as you might expect in a very low-level way which
allows you to change how the compiler works on your own code.
</p>

<p>
FORTH has an INTERPRET function (a true interpreter this time, not DOCOL) which runs in a
loop, reading words (using WORD), looking them up (using FIND), turning them into codeword
pointers (using &gt;CFA) and deciding what to do with them.
</p>

<p>
What it does depends on the mode of the interpreter (in variable STATE).
</p>

<p>
When STATE is zero, the interpreter just runs each word as it looks them up.  This is known as
immediate mode.
</p>

<p>
The interesting stuff happens when STATE is non-zero &#x2013; compiling mode.  In this mode the
interpreter appends the codeword pointer to user memory (the HERE variable points to the next
free byte of user memory &#x2013; see DATA SEGMENT section below).
</p>

<p>
So you may be able to see how we could define : (COLON).  The general plan is:
</p>

<p>
(1) Use WORD to read the name of the function being defined.
</p>

<p>
(2) Construct the dictionary entry &#x2013; just the header part &#x2013; in user memory:
</p>

<pre class="example" id="org0728e4e">
pointer to previous word (from LATEST)                      +-- Afterwards, HERE points here, where
       ^                                                    |   the interpreter will start appending
       |                                                    V   codewords.
    +--|------+---+---+---+---+---+---+---+---+------------+
    | LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      |
    +---------+---+---+---+---+---+---+---+---+------------+
               len                         pad  codeword
</pre>

<p>
(3) Set LATEST to point to the newly defined word, &#x2026;
</p>

<p>
(4) .. and most importantly leave HERE pointing just after the new codeword.  This is where
    the interpreter will append codewords.
</p>

<p>
(5) Set STATE to 1.  This goes into compile mode so the interpreter starts appending codewords to
    our partially-formed header.
</p>

<p>
After : has run, our input is here:
</p>

<pre class="example" id="orge7891bd">
: DOUBLE DUP + ;
         ^
         |
        Next byte returned by KEY will be the 'D' character of DUP
</pre>

<p>
so the interpreter (now it's in compile mode, so I guess it's really the compiler) reads "DUP",
looks it up in the dictionary, gets its codeword pointer, and appends it:
</p>

<pre class="example" id="org62ebfde">
                                                                     +-- HERE updated to point here.
                                                                     |
                                                                     V
+---------+---+---+---+---+---+---+---+---+------------+------------+
| LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP        |
+---------+---+---+---+---+---+---+---+---+------------+------------+
           len                         pad  codeword

Next we read +, get the codeword pointer, and append it:

                                                                                  +-- HERE updated to point here.
                                                                                  |
                                                                                  V
+---------+---+---+---+---+---+---+---+---+------------+------------+------------+
| LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP        | +          |
+---------+---+---+---+---+---+---+---+---+------------+------------+------------+
           len                         pad  codeword
</pre>

<p>
The issue is what happens next.  Obviously what we <span class="underline">don't</span> want to happen is that we
read ";" and compile it and go on compiling everything afterwards.
</p>

<p>
At this point, FORTH uses a trick.  Remember the length byte in the dictionary definition
isn't just a plain length byte, but can also contain flags.  One flag is called the
IMMEDIATE flag (F<sub>IMMED</sub> in this code).  If a word in the dictionary is flagged as
IMMEDIATE then the interpreter runs it immediately <span class="underline">even if it's in compile mode</span>.
</p>

<p>
This is how the word ; (SEMICOLON) works &#x2013; as a word flagged in the dictionary as IMMEDIATE.
</p>

<p>
And all it does is append the codeword for EXIT on to the current definition and switch
back to immediate mode (set STATE back to 0).  Shortly we'll see the actual definition
of ; and we'll see that it's really a very simple definition, declared IMMEDIATE.
</p>

<p>
After the interpreter reads ; and executes it 'immediately', we get this:
</p>

<pre class="example" id="orgd87c6a8">
+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
| LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      | DUP        | +          | EXIT       |
+---------+---+---+---+---+---+---+---+---+------------+------------+------------+------------+
           len                         pad  codeword                                           ^
                                                                                               |
                                                                                              HERE
</pre>
<p>
STATE is set to 0.
</p>

<p>
And that's it, job done, our new definition is compiled, and we're back in immediate mode
just reading and executing words, perhaps including a call to test our new word DOUBLE.
</p>

<p>
The only last wrinkle in this is that while our word was being compiled, it was in a
half-finished state.  We certainly wouldn't want DOUBLE to be called somehow during
this time.  There are several ways to stop this from happening, but in FORTH what we
do is flag the word with the HIDDEN flag (F<sub>HIDDEN</sub> in this code) just while it is
being compiled.  This prevents FIND from finding it, and thus in theory stops any
chance of it being called.
</p>

<p>
The above explains how compiling, : (COLON) and ; (SEMICOLON) works and in a moment I'm
going to define them.  The : (COLON) function can be made a little bit more general by writing
it in two parts.  The first part, called CREATE, makes just the header:
</p>

<pre class="example" id="org8bd0b52">
                                           +-- Afterwards, HERE points here.
                                           |
                                           V
+---------+---+---+---+---+---+---+---+---+
| LINK    | 6 | D | O | U | B | L | E | 0 |
+---------+---+---+---+---+---+---+---+---+
           len                         pad
</pre>

<p>
and the second part, the actual definition of : (COLON), calls CREATE and appends the
DOCOL codeword, so leaving:
</p>

<pre class="example" id="orgd2092db">
                                                        +-- Afterwards, HERE points here.
                                                        |
                                                        V
+---------+---+---+---+---+---+---+---+---+------------+
| LINK    | 6 | D | O | U | B | L | E | 0 | DOCOL      |
+---------+---+---+---+---+---+---+---+---+------------+
           len                         pad  codeword
</pre>

<p>
CREATE is a standard FORTH word and the advantage of this split is that we can reuse it to
create other types of words (not just ones which contain code, but words which contain variables,
constants and other data).
</p>


<div class="org-src-container">
<pre class="src src-asm">defcode "CREATE",6,,CREATE

// Get the name length and address.
pop %ecx                // %ecx = length
pop %ebx                // %ebx = address of name

// Link pointer.
movl var_HERE,%edi      // %edi is the address of the header
movl var_LATEST,%eax    // Get link pointer
stosl                   // and store it in the header.

// Length byte and the word itself.
mov %cl,%al             // Get the length.
stosb                   // Store the length/flags byte.
push %esi
mov %ebx,%esi           // %esi = word
rep movsb               // Copy the word
pop %esi
addl $3,%edi            // Align to next 4 byte boundary.
andl $~3,%edi

// Update LATEST and HERE.
movl var_HERE,%eax
movl %eax,var_LATEST
movl %edi,var_HERE
NEXT
</pre>
</div>


<p>
Because I want to define : (COLON) in FORTH, not assembler, we need a few more FORTH words
to use.
</p>

<p>
The first is , (COMMA) which is a standard FORTH word which appends a 32 bit integer to the user
memory pointed to by HERE, and adds 4 to HERE.  So the action of , (COMMA) is:
</p>

<pre class="example" id="orgc1abd56">
                                                previous value of HERE
                                                         |
                                                         V
+---------+---+---+---+---+---+---+---+---+-- - - - - --+------------+
| LINK    | 6 | D | O | U | B | L | E | 0 |             |  &lt;data&gt;    |
+---------+---+---+---+---+---+---+---+---+-- - - - - --+------------+
           len                         pad                            ^
                                                                      |
                                                                new value of HERE
</pre>

<p>
and &lt;data&gt; is whatever 32 bit integer was at the top of the stack.
</p>

<p>
, (COMMA) is quite a fundamental operation when compiling.  It is used to append codewords
to the current word that is being compiled.
</p>


<div class="org-src-container">
<pre class="src src-asm">	defcode ",",1,,COMMA
	pop %eax                // Code pointer to store.
	call _COMMA
	NEXT
_COMMA:
	movl var_HERE,%edi      // HERE
	stosl                   // Store it.
	movl %edi,var_HERE      // Update HERE (incremented)
	ret
</pre>
</div>

<p>
Our definitions of : (COLON) and ; (SEMICOLON) will need to switch to and from compile mode.
</p>

<p>
Immediate mode vs. compile mode is stored in the global variable STATE, and by updating this
variable we can switch between the two modes.
</p>

<p>
For various reasons which may become apparent later, FORTH defines two standard words called
[ and ] (LBRAC and RBRAC) which switch between modes:
</p>

<p>
Word    Assembler       Action          Effect
[       LBRAC           STATE := 0      Switch to immediate mode.
]       RBRAC           STATE := 1      Switch to compile mode.
</p>

<p>
        [ (LBRAC) is an IMMEDIATE word.  The reason is as follows: If we are in compile mode and the
        interpreter saw [ then it would compile it rather than running it.  We would never be able to
        switch back to immediate mode!  So we flag the word as IMMEDIATE so that even in compile mode
        the word runs immediately, switching us back to immediate mode.
*/
</p>

<p>
defcode "[",1,F<sub>IMMED,LBRAC</sub>
xor %eax,%eax
movl %eax,var<sub>STATE</sub>     // Set STATE to 0.
NEXT
</p>

<p>
defcode "]",1,,RBRAC
movl $1,var<sub>STATE</sub>       // Set STATE to 1.
NEXT
</p>

<p>
/*
        Now we can define : (COLON) using CREATE.  It just calls CREATE, appends DOCOL (the codeword), sets
        the word HIDDEN and goes into compile mode.
*/
</p>

<p>
defword ":",1,,COLON
.int WORD               <i>/ Get the name of the new word
.int CREATE             /</i> CREATE the dictionary entry / header
.int LIT, DOCOL, COMMA  <i>/ Append DOCOL  (the codeword).
.int LATEST, FETCH, HIDDEN /</i> Make the word hidden (see below for definition).
.int RBRAC              <i>/ Go into compile mode.
.int EXIT               /</i> Return from the function.
</p>

<p>
/*
        ; (SEMICOLON) is also elegantly simple.  Notice the F<sub>IMMED</sub> flag.
*/
</p>

<p>
defword ";",1,F<sub>IMMED,SEMICOLON</sub>
.int LIT, EXIT, COMMA   <i>/ Append EXIT (so the word will return).
.int LATEST, FETCH, HIDDEN /</i> Toggle hidden flag &#x2013; unhide the word (see below for definition).
.int LBRAC              <i>/ Go back to IMMEDIATE mode.
.int EXIT               /</i> Return from the function.
</p>

<p>
/*
        EXTENDING THE COMPILER -----------------------------------------------------------------&#x2013;&#x2014;
</p>

<p>
Words flagged with IMMEDIATE (F<sub>IMMED</sub>) aren't just for the FORTH compiler to use.  You can define
your own IMMEDIATE words too, and this is a crucial aspect when extending basic FORTH, because
it allows you in effect to extend the compiler itself.  Does gcc let you do that?
</p>

<p>
Standard FORTH words like IF, WHILE, ." and so on are all written as extensions to the basic
compiler, and are all IMMEDIATE words.
</p>

<p>
The IMMEDIATE word toggles the F<sub>IMMED</sub> (IMMEDIATE flag) on the most recently defined word,
or on the current word if you call it in the middle of a definition.
</p>

<p>
Typical usage is:
</p>

<pre class="example">
MYIMMEDWORD IMMEDIATE
</pre>

<p>
	&#x2026;definition&#x2026;
;
</p>

<p>
but some FORTH programmers write this instead:
</p>

<pre class="example">
MYIMMEDWORD
</pre>

<p>
	&#x2026;definition&#x2026;
; IMMEDIATE
</p>

<p>
        The two usages are equivalent, to a first approximation.
*/
</p>

<p>
defcode "IMMEDIATE",9,F<sub>IMMED,IMMEDIATE</sub>
movl var<sub>LATEST</sub>,%edi    <i>/ LATEST word.
addl $4,%edi            /</i> Point to name/flags byte.
xorb $F<sub>IMMED</sub>,(%edi)    // Toggle the IMMED bit.
NEXT
</p>

<p>
/*
        'addr HIDDEN' toggles the hidden flag (F<sub>HIDDEN</sub>) of the word defined at addr.  To hide the
        most recently defined word (used above in : and ; definitions) you would do:
</p>

<p>
LATEST @ HIDDEN
</p>

<p>
'HIDE word' toggles the flag on a named 'word'.
</p>

<p>
Setting this flag stops the word from being found by FIND, and so can be used to make 'private'
words.  For example, to break up a large word into smaller parts you might do:
</p>

<pre class="example">
SUB1 ... subword ... ;
SUB2 ... subword ... ;
SUB3 ... subword ... ;
MAIN ... defined in terms of SUB1, SUB2, SUB3 ... ;
</pre>

<p>
HIDE SUB1
HIDE SUB2
HIDE SUB3
</p>

<p>
        After this, only MAIN is 'exported' or seen by the rest of the program.
*/
</p>

<p>
defcode "HIDDEN",6,,HIDDEN
pop %edi                <i>/ Dictionary entry.
addl $4,%edi            /</i> Point to name/flags byte.
xorb $F<sub>HIDDEN</sub>,(%edi)   // Toggle the HIDDEN bit.
NEXT
</p>

<p>
defword "HIDE",4,,HIDE
.int WORD               <i>/ Get the word (after HIDE).
.int FIND               /</i> Look up in the dictionary.
.int HIDDEN             <i>/ Set F<sub>HIDDEN</sub> flag.
.int EXIT               /</i> Return.
</p>

<p>
/*
        ' (TICK) is a standard FORTH word which returns the codeword pointer of the next word.
</p>

<p>
The common usage is:
</p>

<p>
' FOO ,
</p>

<p>
which appends the codeword of FOO to the current word we are defining (this only works in compiled code).
</p>

<p>
You tend to use ' in IMMEDIATE words.  For example an alternate (and rather useless) way to define
a literal 2 might be:
</p>

<pre class="example">
LIT2 IMMEDIATE
</pre>

<p>
	' LIT ,         \ Appends LIT to the currently-being-defined word
	2 ,             \ Appends the number 2 to the currently-being-defined word
;
</p>

<p>
So you could do:
</p>

<pre class="example">
DOUBLE LIT2 * ;
</pre>


<p>
(If you don't understand how LIT2 works, then you should review the material about compiling words
and immediate mode).
</p>

<p>
        This definition of ' uses a cheat which I copied from buzzard92.  As a result it only works in
        compiled code.  It is possible to write a version of ' based on WORD, FIND, &gt;CFA which works in
        immediate mode too.
*/
        defcode "'",1,,TICK
        lodsl                   <i>/ Get the address of the next word and skip it.
        pushl %eax              /</i> Push it on the stack.
        NEXT
</p>

<p>
/*
        BRANCHING -----------------------------------------------------------------&#x2013;&#x2014;
</p>

<p>
It turns out that all you need in order to define looping constructs, IF-statements, etc.
are two primitives.
</p>

<p>
BRANCH is an unconditional branch. 0BRANCH is a conditional branch (it only branches if the
top of stack is zero).
</p>

<p>
The diagram below shows how BRANCH works in some imaginary compiled word.  When BRANCH executes,
%esi starts by pointing to the offset field (compare to LIT above):
</p>

<p>
<del>---------------------</del>-------<del>-&#x2014; - - ---</del>------------<del>------------</del>-&#x2014; - - - ----<del>------------</del>
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">(Dictionary header)</td>
<td class="org-left">DOCOL</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">BRANCH</td>
<td class="org-left">offset</td>
<td class="org-left">(skipped)</td>
<td class="org-left">word</td>
</tr>
</tbody>
</table>
<p>
<del>---------------------</del>-------<del>-&#x2014; - - ---</del>------------<del>&#x2013;&#x2014;|------</del>-&#x2014; - - - ----<del>------------</del>
							   ^  |                       ^
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><del>-----------------------</del></td>
</tr>
</tbody>
</table>
<p>
%esi added to offset
</p>

<p>
The offset is added to %esi to make the new %esi, and the result is that when NEXT runs, execution
continues at the branch target.  Negative offsets work as expected.
</p>

<p>
0BRANCH is the same except the branch happens conditionally.
</p>

<p>
Now standard FORTH words such as IF, THEN, ELSE, WHILE, REPEAT, etc. can be implemented entirely
in FORTH.  They are IMMEDIATE words which append various combinations of BRANCH or 0BRANCH
into the word currently being compiled.
</p>

<p>
As an example, code written like this:
</p>

<p>
condition-code IF true-part THEN rest-code
</p>

<p>
compiles to:
</p>

<p>
condition-code 0BRANCH OFFSET true-part rest-code
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
                                          <del>-------------</del>
*/
</p>

<p>
defcode "BRANCH",6,,BRANCH
add (%esi),%esi         // add the offset to the instruction pointer
NEXT
</p>

<p>
defcode "0BRANCH",7,,ZBRANCH
pop %eax
test %eax,%eax          <i>/ top of stack is zero?
jz code<sub>BRANCH</sub>          /</i> if so, jump back to the branch function above
lodsl                   // otherwise we need to skip the offset
NEXT
</p>

<p>
/*
        LITERAL STRINGS -----------------------------------------------------------------&#x2013;&#x2014;
</p>

<p>
LITSTRING is a primitive used to implement the ." and S" operators (which are written in
FORTH).  See the definition of those operators later.
</p>

<p>
        TELL just prints a string.  It's more efficient to define this in assembly because we
        can make it a single Linux syscall.
*/
</p>

<p>
defcode "LITSTRING",9,,LITSTRING
lodsl                   <i>/ get the length of the string
push %esi               /</i> push the address of the start of the string
push %eax               <i>/ push it on the stack
addl %eax,%esi          /</i> skip past the string
addl $3,%esi            // but round up to next 4 byte boundary
andl $~3,%esi
NEXT
</p>

<p>
defcode "TELL",4,,TELL
mov $1,%ebx             <i>/ 1st param: stdout
pop %edx                /</i> 3rd param: length of string
pop %ecx                <i>/ 2nd param: address of string
mov $_<sub>NR</sub><sub>write</sub>,%eax    /</i> write syscall
int $0x80
NEXT
</p>

<p>
/*
        QUIT AND INTERPRET -----------------------------------------------------------------&#x2013;&#x2014;
</p>

<p>
QUIT is the first FORTH function called, almost immediately after the FORTH system "boots".
As explained before, QUIT doesn't "quit" anything.  It does some initialisation (in particular
it clears the return stack) and it calls INTERPRET in a loop to interpret commands.  The
reason it is called QUIT is because you can call it from your own FORTH words in order to
"quit" your program and start again at the user prompt.
</p>

<p>
        INTERPRET is the FORTH interpreter ("toploop", "toplevel" or "REPL" might be a more accurate
        description &#x2013; see: <a href="http://en.wikipedia.org/wiki/REPL">http://en.wikipedia.org/wiki/REPL</a>).
*/
</p>

<p>
// QUIT must not return (ie. must not call EXIT).
defword "QUIT",4,,QUIT
.int RZ,RSPSTORE        <i>/ R0 RSP!, clear the return stack
.int INTERPRET          /</i> interpret the next word
.int BRANCH,-8          // and loop (indefinitely)
</p>

<p>
/*
        This interpreter is pretty simple, but remember that in FORTH you can always override
        it later with a more powerful one!
 */
        defcode "INTERPRET",9,,INTERPRET
        call _WORD              // Returns %ecx = length, %edi = pointer to word.
</p>

<p>
// Is it in the dictionary?
xor %eax,%eax
movl %eax,interpret<sub>is</sub><sub>lit</sub> <i>/ Not a literal number (not yet anyway &#x2026;)
call _FIND              /</i> Returns %eax = pointer to header or 0 if not found.
test %eax,%eax          // Found?
jz 1f
</p>

<p>
<i>/ In the dictionary.  Is it an IMMEDIATE codeword?
mov %eax,%edi           /</i> %edi = dictionary entry
movb 4(%edi),%al        <i>/ Get name+flags.
push %ax                /</i> Just save it for now.
call _TCFA              // Convert dictionary entry (in %edi) to codeword pointer.
pop %ax
andb $F<sub>IMMED</sub>,%al       // Is IMMED flag set?
mov %edi,%eax
jnz 4f                  // If IMMED, jump straight to executing.
</p>

<p>
jmp 2f
</p>

<p>
1:      // Not in the dictionary (not a word) so assume it's a literal number.
        incl interpret<sub>is</sub><sub>lit</sub>
        call _NUMBER            // Returns the parsed number in %eax, %ecx &gt; 0 if error
        test %ecx,%ecx
        jnz 6f
        mov %eax,%ebx
        mov $LIT,%eax           // The word is LIT
</p>

<p>
2:      // Are we compiling or executing?
        movl var<sub>STATE</sub>,%edx
        test %edx,%edx
        jz 4f                   // Jump if executing.
</p>

<p>
        // Compiling - just append the word to the current dictionary definition.
        call _COMMA
        mov interpret<sub>is</sub><sub>lit</sub>,%ecx // Was it a literal?
        test %ecx,%ecx
        jz 3f
        mov %ebx,%eax           // Yes, so LIT is followed by a number.
        call _COMMA
3:      NEXT
</p>

<p>
4:      <i>/ Executing - run it!
        mov interpret<sub>is</sub><sub>lit</sub>,%ecx /</i> Literal?
        test %ecx,%ecx          // Literal?
        jnz 5f
</p>

<p>
<i>/ Not a literal, execute it now.  This never returns, but the codeword will
/</i> eventually call NEXT which will reenter the loop in QUIT.
jmp *(%eax)
</p>

<p>
5:      // Executing a literal, which means push it on the stack.
        push %ebx
        NEXT
</p>

<p>
6:      <i>/ Parse error (not a known word or a number in the current BASE).
        /</i> Print an error message followed by up to 40 characters of context.
        mov $2,%ebx             <i>/ 1st param: stderr
        mov $errmsg,%ecx        /</i> 2nd param: error message
        mov $errmsgend-errmsg,%edx <i>/ 3rd param: length of string
        mov $_<sub>NR</sub><sub>write</sub>,%eax    /</i> write syscall
        int $0x80
</p>

<p>
        mov (currkey),%ecx      // the error occurred just before currkey position
        mov %ecx,%edx
        sub $buffer,%edx        <i>/ %edx = currkey - buffer (length in buffer before currkey)
        cmp $40,%edx            /</i> if &gt; 40, then print only 40 characters
        jle 7f
        mov $40,%edx
7:      sub %edx,%ecx           <i>/ %ecx = start of area to print, %edx = length
        mov $_<sub>NR</sub><sub>write</sub>,%eax    /</i> write syscall
        int $0x80
</p>

<p>
mov $errmsgnl,%ecx      // newline
mov $1,%edx
mov $_<sub>NR</sub><sub>write</sub>,%eax    // write syscall
int $0x80
</p>

<p>
NEXT
</p>

<p>
        .section .rodata
errmsg: .ascii "PARSE ERROR: "
errmsgend:
errmsgnl: .ascii "\n"
</p>

<p>
        .data                   // NB: easier to fit in the .data section
        .align 4
interpret<sub>is</sub><sub>lit</sub>:
        .int 0                  // Flag used to record if reading a literal
</p>

<p>
/*
        ODDS AND ENDS -----------------------------------------------------------------&#x2013;&#x2014;
</p>

<p>
CHAR puts the ASCII code of the first character of the following word on the stack.  For example
CHAR A puts 65 on the stack.
</p>

<p>
EXECUTE is used to run execution tokens.  See the discussion of execution tokens in the
FORTH code for more details.
</p>

<p>
SYSCALL0, SYSCALL1, SYSCALL2, SYSCALL3 make a standard Linux system call.  (See &lt;asm/unistd.h&gt;
for a list of system call numbers).  As their name suggests these forms take between 0 and 3
syscall parameters, plus the system call number.
</p>

<p>
        In this FORTH, SYSCALL0 must be the last word in the built-in (assembler) dictionary because we
        initialise the LATEST variable to point to it.  This means that if you want to extend the assembler
        part, you must put new words before SYSCALL0, or else change how LATEST is initialised.
*/
</p>

<p>
defcode "CHAR",4,,CHAR
call _WORD              // Returns %ecx = length, %edi = pointer to word.
xor %eax,%eax
movb (%edi),%al         <i>/ Get the first character of the word.
push %eax               /</i> Push it onto the stack.
NEXT
</p>

<p>
defcode "EXECUTE",7,,EXECUTE
pop %eax                <i>/ Get xt into %eax
jmp *(%eax)             /</i> and jump to it.
			// After xt runs its NEXT will continue executing the current word.
</p>

<p>
defcode "SYSCALL3",8,,SYSCALL3
pop %eax                <i>/ System call number (see &lt;asm/unistd.h&gt;)
pop %ebx                /</i> First parameter.
pop %ecx                <i>/ Second parameter
pop %edx                /</i> Third parameter
int $0x80
push %eax               // Result (negative for -errno)
NEXT
</p>

<p>
defcode "SYSCALL2",8,,SYSCALL2
pop %eax                <i>/ System call number (see &lt;asm/unistd.h&gt;)
pop %ebx                /</i> First parameter.
pop %ecx                // Second parameter
int $0x80
push %eax               // Result (negative for -errno)
NEXT
</p>

<p>
defcode "SYSCALL1",8,,SYSCALL1
pop %eax                <i>/ System call number (see &lt;asm/unistd.h&gt;)
pop %ebx                /</i> First parameter.
int $0x80
push %eax               // Result (negative for -errno)
NEXT
</p>

<p>
defcode "SYSCALL0",8,,SYSCALL0
pop %eax                // System call number (see &lt;asm/unistd.h&gt;)
int $0x80
push %eax               // Result (negative for -errno)
NEXT
</p>

<p>
/*
        DATA SEGMENT -----------------------------------------------------------------&#x2013;&#x2014;
</p>

<p>
Here we set up the Linux data segment, used for user definitions and variously known as just
the 'data segment', 'user memory' or 'user definitions area'.  It is an area of memory which
grows upwards and stores both newly-defined FORTH words and global variables of various
sorts.
</p>

<p>
It is completely analogous to the C heap, except there is no generalised 'malloc' and 'free'
(but as with everything in FORTH, writing such functions would just be a Simple Matter
Of Programming).  Instead in normal use the data segment just grows upwards as new FORTH
words are defined/appended to it.
</p>

<p>
There are various "features" of the GNU toolchain which make setting up the data segment
more complicated than it really needs to be.  One is the GNU linker which inserts a random
"build ID" segment.  Another is Address Space Randomization which means we can't tell
where the kernel will choose to place the data segment (or the stack for that matter).
</p>

<p>
Therefore writing this set<sub>up</sub><sub>data</sub><sub>segment</sub> assembler routine is a little more complicated
than it really needs to be.  We ask the Linux kernel where it thinks the data segment starts
using the brk(2) system call, then ask it to reserve some initial space (also using brk(2)).
</p>

<p>
        You don't need to worry about this code.
*/
        .text
        .set INITIAL<sub>DATA</sub><sub>SEGMENT</sub><sub>SIZE,65536</sub>
set<sub>up</sub><sub>data</sub><sub>segment</sub>:
        xor %ebx,%ebx           // Call brk(0)
        movl $_<sub>NR</sub><sub>brk</sub>,%eax
        int $0x80
        movl %eax,var<sub>HERE</sub>      <i>/ Initialise HERE to point at beginning of data segment.
        addl $INITIAL<sub>DATA</sub><sub>SEGMENT</sub><sub>SIZE</sub>,%eax    /</i> Reserve nn bytes of memory for initial data segment.
        movl %eax,%ebx          // Call brk(HERE+INITIAL<sub>DATA</sub><sub>SEGMENT</sub><sub>SIZE</sub>)
        movl $_<sub>NR</sub><sub>brk</sub>,%eax
        int $0x80
        ret
</p>

<p>
/*
        We allocate static buffers for the return static and input buffer (used when
        reading in files and text that the user types in).
*/
        .set RETURN<sub>STACK</sub><sub>SIZE,8192</sub>
        .set BUFFER<sub>SIZE,4096</sub>
</p>

<p>
        .bss
<i>* FORTH return stack. *</i>
        .align 4096
return<sub>stack</sub>:
        .space RETURN<sub>STACK</sub><sub>SIZE</sub>
return<sub>stack</sub><sub>top</sub>:               // Initial top of return stack.
</p>

<p>
<i>* This is used as a temporary input buffer when reading from files or the terminal. *</i>
        .align 4096
buffer:
        .space BUFFER<sub>SIZE</sub>
</p>

<p>
/*
        START OF FORTH CODE -----------------------------------------------------------------&#x2013;&#x2014;
</p>

<p>
We've now reached the stage where the FORTH system is running and self-hosting.  All further
words can be written as FORTH itself, including words like IF, THEN, .", etc which in most
languages would be considered rather fundamental.
</p>

<p>
I used to append this here in the assembly file, but I got sick of fighting against gas's
crack-smoking (lack of) multiline string syntax.  So now that is in a separate file called
jonesforth.f
</p>

<p>
        If you don't already have that file, download it from <a href="http://annexia.org/forth">http://annexia.org/forth</a> in order
        to continue the tutorial.
*/
</p>


<p>
<i>* END OF jonesforth.S *</i>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Guido Bartolucci</p>
<p class="date">Created: 2022-04-06 Wed 23:31</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
